---
title: Java基础
date: 2021-11-15 20:35:56
tags: Java

---

## 序言

计算机革命起源于机器，因此，编程语言的产生也始于对机器的模仿

---

<!-- more -->

# Chapter 01 对象导论

人们所能够解决的问题的复杂性直接取决于抽象的类型和质量

## 1.1 抽象过程

**所有编程语言都提供抽象机制**

汇编是对底层机器的抽象，命令式语言是对汇编语言的抽象；

汇编、命令式语言在解决问题时仍要基于计算机结构来考虑，而不是基于问题结构；

程序员需要建立在机器模型与问题模型之间的关联；

面向对象设计提供了一种工具，用于在机器空间中表示问题空间中的元素，称其为“对象”；

## 1.2 每个对象都有一个接口

**所有对象都是唯一的，但具有相同特性和行为的对象归属于一个类**

面向对象程序设计的挑战：问题空间的元素与解空间的对象之间的映射关系

如何获得有用的对象：对象能够满足的请求，这些请求由接口定义，具体代码与隐藏的数据构成<u>实现</u>（即接口的实现类）

## 1.3 每个对象都提供服务

程序设计的思路：程序本身向用户提供服务，它将通过调用对象提供的服务来实现程序的功能，而我们只需要去创建（或从现有代码库中寻找）能够提供理想的服务来解决问题的一系列对象。

## 1.4 被隐藏的具体实现

程序开发人员的分类：类创建者(创建新数据类型的程序员)和类消费者（在应用中使用数据类型的应用程序员）

为什么隐藏：将部分实现隐藏起来可以减少程序Bug

三个关键字在类的内部设定边界(访问指定词)：public、private、protected

## 1.5 复用具体实现

简单来说，当一个类被创建并被测试完后，在程序中经常使用，且能被其他类所包含，即为可复用。

## 1.6 继承

简述：以现有的类为基础，复制它，然后通过添加和修改这个副本来创建新类

特点：类型不仅仅只描述了作用于一个对象集合上的约束条件，同时还有与其他类型之间的关系，即通过继承而产生的类型等价性

## 1.7 伴随多态的可互换对象

**原因**：当遇到类型的层次结构，处理对象时不用关注它所属的特定类型，而是将其当作基类的对象来对待，这也称之为**泛化对象**

后期绑定：编译器确保泛化对象的被调用方法是否存在，并对调用参数和返回值执行类型检查

好处：有时编译器并不需要知道所处理的对象的确切类型，通常希望调用基类的方法，更具有普适性(通用性)

## 1.8 单根继承结构

**问题**：OOP中，是否所有的类最终都继承自单一的基类？Java中有Object这个单一基类

好处：即所有对象都具有一个公共接口，保证所有对象都具有某些功能，因而我们可以在每个对象上执行某些基本操作

## 1.9 容器

**问题**：在解决某个特定问题时，需要多少空间对象，它们将存活多久？

容器：创建一种新的对象类型，这种对象持有对其他对象的引用，通常用数组类型来实现

功能：容器可以在任何时候扩充自己以容纳你置于其中的所有东西

Java标准类库中的容器：具有满足不同需要的各种类型的容器，例如List，Map，Set，以及队列、树、堆栈等更多的构件

从设计的观点来看，真正需要的只是一个可以操作，从而解决问题的序列。但是单一类型的容器无法满足所有需要，两个原因：

1. 不同容器提供了不同类型的接口和外部行为
2. 不同的容器对于某些操作具有不同的效率

例子：ArrayList和LinkedList，它们都具有相同的接口和外部行为，但是它们对于某些操作所花费的代价却有天壤之别：

1. 对于ArrayList来说，随机访问元素是一个花费固定时间的操作，但对于LinkedList来说，随机访问元素需要在序列中移动，这种代价是高昂的，越是接近表尾，代价越大
2. 如果想在序列中插入一个元素，LinkedList的开销要比ArrayList小
3. 我们可以一开始使用LinkedList构件程序，而在优化系统性能时该用ArrayList，而此时接口List所带来的抽象，把在容器之间进行转换时，对代码产生的影响降到最小

## 1.10 参数化类型

在Java SE5出现之前，容器存储的对象只有Java中的通用类型：Object，由于单根继承的机制，所有东西都是Object类型，所以存储Object类型的容器可以存储任何东西

使用容器，只需要把对象的引用置入其中，稍后将其取出，但是由于容器只存储Object，所以当将对象引用置入容器时，它必须被向上转型为Object，因此它会丢失原有的身份。当把它取回时，就获得了一个对Object对象的引用，而不是置入时那个类型的对象的引用。

**问题**：怎样才能将它变回先前置入容器中时的具有实用接口的对象呢？

此处再度使用到了转型，这一次不是向继承结构的上层转型为一个更加泛化的类型，而是向下转型为更具体的类型，称其为向下转型。在此过程中，向上转型是安全的，向下转型是不安全的，错误的转型会得到称为异常的运行时错误。

尽管不安全，但是从容器中取出对象引用时，还是必须要以某种方式记住这些对象是什么类型，这样才能执行正确的向下转型。

解决方案：创建这样的一个容器，它知道自己所保存的对象的类型，不必手动向下转型以及消除错误，这样的方法称为参数化类型机制。

参数化类型：就是一个编译器可以自动定制作用于特定类型的类，在Java SE5的时候出现，称之为泛型

泛型：一对尖括号，中间包含类型信息，通过这些特征就可以识别对泛型的使用。

```java
ArrayList<Shape> shapes = new ArrayList<Shape>()
```

## 1.11 对象的创建和生命期

**问题**：使用对象时，它们的生成和销毁是如何处理的

相对简单的编程情况下，我们需要对象，创建对象，根据需要使用它，然后销毁它

在复杂的编程情况下，我们需要对象，创建对象，在某种情况下使用它，但不能立刻销毁，它可能会在其他的情况下被使用，却也可能再也不用

**复杂的问题**：对象的数据位于何处？怎样控制对象的生命周期？

C++认为效率控制是最重要的议题，为了追求效率，对象的存储空间和生命周期可以再编程时确定，这可以通过将对象置于堆栈内来实现。虽然在某些情况下，这样控制非常具有价值，但是牺牲了灵活性，因为在编写程序时，就需要知道对象确切的数量、生命周期和类型。

第二种方式的控制，是在被称为堆区的内存池中动态的创建对象。对象的确定（数量、生命周期、具体类型）需要在运行时才知道。因为存储空间是在运行时被动态管理的，所以需要大量的时间在堆中分配存储空间，这可能要远远大于在堆栈中创建存储空间的时间。

在堆栈中创建存储空间和释放存储空间常常只需要一条汇编指令即可，分别对应将栈顶指针向下移动和将栈顶指针向上移动。而创建堆存储空间的时间依赖于存储机制的设计。

Java完全采用了动态内存分配方式，每当想要创建新的对象时，就要使用new关键字来构件此对象的动态实例。

还有一个议题，就是对象生命周期。对允许在堆栈上创建对象的语言，编译器可以确定对象的存活时间，并自动销毁它。如果是在堆上创建对象，编译器就会对它的生命周期一无所知。C++中，必须通过编程的方式来确定何时销毁对象，这可能为不能正确处理而导致内存泄露。Java提供了被称为“垃圾回收器”的机制，它可以自动发现对象何时不再使用，并继而销毁它。

Java的垃圾回收器被设计用来处理内存释放的问题。这一点是结合了单根继承Object以及只在堆上创建对象，这两个特性结合起来，使得用Java编程的过程较C++更为简单。

## 1.12 异常处理

问题：自编程语言问世以来，错误处理就始终是一个最困难的问题之一

异常处理将错误处理直接置于编程语言中，有时甚至于操作系统中。异常是一种对象，它从出错点被“抛出”，并被专门设计用来处理特定类型错误的相应的异常处理器“捕获“。异常处理就像是与程序正常执行路径并行的，在错误发送时执行的另一条路径。因为它是另外一条完全分离的执行路径，所以它不会干扰正常的执行代码。

此外，被抛出的异常不像方法返回的错误值和方法设置的用来表示错误条件的标识位那样可以被忽略，异常不能被忽略，所以它保证一定会在某处得到处理。即异常提供了一种从错误状况进行可靠回复的途径。

## 1.13 并发编程

问题：希望充分利用CPU资源，在同一时刻可以处理多个任务

许多程序设计问题都要求，程序能够停下正在做的工作，转而处理某个问题，然后再返回主进程。最初，程序员们用所掌握的有关机器底层的知识来编写中断服务程序。主进程的挂起是通过硬件中断来触发的。但这样做难度太大，且不可移植。

对于大量问题，我们只想把问题切分成多个可独立运行的部分（任务），从而提高程序的响应能力。在程序中，这些彼此独立运行的部分称之为线程，上述概念被称为“并发”。

并发执行有一个隐患：共享资源，如果有多个进程都访问一项资源，那么就会出问题。为了解决问题，在某个任务锁定某项资源时，完成其任务，然后释放资源，使其他任务可以使用这项资源。

## 1.14 Java与Internet

Java仅仅是众多的程序设计语言中的一种，它突出的表现在于解决了在万维网（www）上的程序设计问题

### 1.14.1 Web是什么

客户端/服务器技术：系统具有一个信息存储池，存储某种数据，根据需要分发给用户。具体描述一下，信息存储池、分发信息的软件以及适配的机器所构成的一个整体系统，称为服务器。驻留在用户机器上的软件能与服务器通信，接收某种数据并显示在客户机器上，称之为客户端。

C/S关键技术：一个服务器需要同时为多个客户服务，涉及数据库管理的“均衡问题”。服务器如何更新客户端在其存储的信息，涉及事物处理。客户端软件的更新，涉及跨平台的问题。对于大量的客户端的响应延迟，涉及性能问题。

**问题1**：分发信息是个简单的思想，但在实际操作上具有不同层次的复杂性。在过去，都是针对每个问题发明一个单独的解决方案，所以每一次都要发明一个新的方案。这些方案难以开发且难以使用，而且用户对每一个方案都要学习新的接口。因此，需要对C/S问题进行彻底解决。

**问题2**：Web客户端与服务器信息交互，需求逐渐升级。最初只有一种很简单的过程，客户端对服务器进行请求，服务器响应并返回一个文件，客户端的浏览器软件根据本地机器的格式来解读这个文件。但是人们希望交互的功能更多，不仅仅服务器返回页面，客户端可以将信息反馈给服务器，例如在服务器上的数据库查找。

**问题3**：一段信息不经修改就可以在任意型号的计算上显示，即需要在客户端上增设对应的图形标准和程序运行能力

### 1.14.2 客户端编程

### 1.14.3 服务器编程

# chapter 02 一切都是对象

“如果我们说另一种不同的语言，那么我们就会发觉一个有些不同的世界” — Luduing wittgerstein

## 2.1 用引用操作对象

每种编程语言都有自己操作内存中元素的方式。程序员需要时刻注意要处理的数据是什么类型。是直接操纵元素，还是基于指针间接操作元素。

**问题**：Java中将一切视为对象，那么如何来操纵对象呢？

1. 我们通过“引用（reference）”这个标识符来操纵对象，这个引用类似于C++的引用，但是区别于指针。

2. 引用和对象可分离构造，若想操作字符或字符串，创建一个String的引用，但不构造对象

   ```java
   String s;
   ```

3. 不过此时向 s 发送一个消息，会返回运行时错误，因此创建引用的同时，也要初始化

   ```java
   String s = "asdf";
   ```

   这里用到了一个**Java特性**，字符串可以用带引号的文本初始化。（不过，尽量使用通用初始化方法）

## 2.2 必须由你创建所有对象

一旦创建了一个引用，就希望它能与一个新的对象相关联。通常用new操作符来实现这一目的。new关键字的意思是“给我一个新对象”，即前面的例子可以写成

```java
String s = new String("asdf");
```

**问题：**程序运行时，对象是怎么进行放置安排的呢？特别是内存是怎样分配的呢？

有五个地方可以存储数据

1. 寄存器
2. 堆栈（RAM）：堆栈指针的上下移动，可以对内存进行分配和释放，对象引用存储在这里。
3. 堆（RAM）：存放所有的Java对象，堆不同于堆栈，编译器不需要知道存储的数据在堆里存活多长时间。
4. 常量存储：常量值通常直接存放在程序代码的内部，以防改变。在嵌入式系统中华，有时会放在ROM中。
5. 非RAM存储：数据完全存活于程序之外，可不受程序的任何控制。即流对象和持久化对象

**问题**：除了对象以外的数据类型？

在程序设计中，常用到的一系列类型，它们需要特殊对待。称之为“基本”类型

1. 由new将对象存储在“堆”中，对于小的、简单的变量，往往不是很有效。
2. Java采取与C/C++相同的做法，不用new，而是创建一个并非是“引用”的“自动”变量。
3. 这个变量直接存储“值”，并将其置于堆栈中，因而更加高效。

Java要确定每种基本类型所占据存储空间的大小，它们的大小不像其他大多数语言那样随着机器硬件架构的变化而变化。因而这种占存储空间大小的**不变性**是Java程序比用其他大多数语言所编写的程序，更具**移植性**。

| 基本类型 | 大小    | 最小值    | 最大值           | 包装器类型 |
| -------- | ------- | --------- | ---------------- | ---------- |
| boolean  | —       | —         | —                | Boolean    |
| char     | 16-bit  | Unicode 0 | Unicode 2^16 - 1 | Character  |
| byte     | 8 bits  | -128      | +127             | Byte       |
| short    | 16 bits | -2^15     | +2^15 -1         | Short      |
| int      | 32 bits | -2^31     | +2^31 - 1        | Int        |
| long     | 64 bits | -2^63     | +2^63 - 1        | Long       |
| Float    | 32 bits | IEEE754   | IEEE754          | Float      |
| double   | 64 bits | IEEE754   | IEEE754          | Double     |
| void     | —       | —         | —                | Void       |

所有数值类型都有正负号，不要去找无符号的数值类型

基本类型具有的包装器类，使得可以在堆中创建对应基本类型的一个非基本对象，例如

```java
char c = 'x';
Character ch = new Character(c)；
// 也可以这样用
Character ch = new Character('x')；
// Java SE5的自动包装功能，将自动地将基本类型转换为包装器类型
Character ch = 'x'；
// 也可以反向转换
char c = ch；
```

高精度数字，Java提供了两个用于高精度计算的类：BigInteger和BigDecimal。虽然它们没有对应的基本类型，但是这两个类包含的方法，与基本类型所能执行的操作类型。也就是说，作用在int和float上的操作，也同样能作用于BigInteger和BigDecimal。具体来说，就是必须使用以调用方法的方式来取代运算符的方式。但这么做复杂了许多，所以运算速度会比较慢。主要是以速度换取了精度。

**问题**：几乎所有程序语言都支持数组，那么在Java中，数组是如何表现/实现的呢？

在C/C++中使用数组是很危险的，因为C/C++中的数组就是内存块，如果一个程序要访问自身内存块之外的数组，或在数组初始化前使用内存，都会产生难以预料的后果。

1. Java的主要目标之一就是安全性，Java会确保数组被初始化，而且不能在它的范围之外被访问，虽然会有额外的内存开销和运行时的下标检查。但这样的付出是值得的。
2. 数组对象的创建，实际上是创建了一个引用数组，并且每个引用初始化为关键字null，用于运行时检查。
3. 当然还可以创造用来存放基本数据类型的数组，且编译器会自动初始化置零。

## 2.3 永远不需要销毁对象

**问题**：在大多数程序语言设计中，变量生命周期的概念，占据了程序设计工作中非常重要的部分。变量存活需要多长时间？何时可以销毁对象？变量生命周期的混乱往往导致大量的程序bug，让我们看看Java是如何处理的。

### 2.3.1 作用域

在大多数过程语言都有作用域(scope)的概念。作用域决定了在其内定义的变量名的可见性和生命周期，在C/C++和Java中，作用域由花括号的位置决定。例如：

```java
{
	int x = 12;
	// 只有x可获得
	{
		int q = 96;
    // x和q都可获得
	}
	// 只有x可获得
	// q不在当前的作用域内
}
```

在作用域里定义的变量只可用于作用域结束之前。

## 2.3.2 对象的作用域

不过Java对象不具备和基本类型一样的生命周期。当用new创建一个Java对象，它仍可以存活于作用域之外。

```java
{
	String s = new String("a String");
} // 作用域结束
```

引用s在作用域结束后就消失了，而s指向的String对象仍然占据内存空间。在这一小段代码中，我们无法在这个作用域之后访问这个对象，因为对它唯一的引用已经超出了作用域的范围。当然，在后面通过值传递，可以复制对象引用。

1. 因而new构造的对象，只要需要，就会一直存在。若不需要呢？
2. 如果不需要，则Java的垃圾回收器会监视new创建的对象，辨识不再使用的对象，随后释放这些对象的内存。

## 2.4 创建新的数据类型：类

问题：如果一切都是对象，如何决定某一类对象的特征与行为？

大多数程序语言都习惯用class这个关键字来表示“新类型的对象所具备的字段和方法”。

```java
class ATypeName{/* 类的主体部分 */}
```

这就引入了一种新的类型，但这个新的类型只有一条注释，因而我们还不能使用它做太多的事情。不过我们可以用new来创建这种类型的对象。

```java
ATypeName a = new ATypeName()；
```

现在还不能向它发送任何有意义的消息。

### 2.4.1 字段和方法

在定义类的过程中，除了上述步骤外，我们还可以在类中设置两种类型的元素：字段和方法

1. 字段可以是任何类型的对象，可以通过引用与其进行通信；也可以是基本类型的一种。

2. 每个对象都有用来存储其字段的空间；普通字段不能在对象间共享（默认private）

   ```java
   class DataOnly{
   	int i;
   	double d;
   	boolean b;
   }
   ```

   同样，我们可以创建它的一个对象，虽然只能用于存储数据

   ```java
   DataOnly data = new DataOnly()
   ```

3. 我们可以给字段赋值，但首先必须知道如何引用一个对象的成员。具体的实现为：在对象引用的名称后紧接一个句点，然后接着是对象内部的成员名称：

   ```java
   data.i = 47;
   data.d = 1.1;
   data.b = false;
   ```

4. 如果需要修改的字段，在对象所包含的其他对象中，可以使用连续句点

   ```java
   bigData.data.i = 100；
   ```

5. 上面的DataOnly类除了保存数据外没有别的用处，因为它没有任何成员方法。想要了解成员方法的运行机制，得先了解参数和返回值的概念。

6. 若类的某个成员是基本数据类型，且没有初始化，Java也会确保它获得一个默认值

   | 基本类型 | 默认值           |
   | -------- | ---------------- |
   | boolean  | false            |
   | char     | ‘\u0000’（null） |
   | byte     | (byte) 0         |
   | short    | (short) 0        |
   | int      | 0                |
   | long     | 0L               |
   | float    | 0.0f             |
   | double   | 0.0d             |

7. 不过上述确保初始化的方式并不适用于“局部变量”（并非每个类的字段，而是在方法中定义变量）

```java
// 在方法中定义局部变量，若没有初始化，则Java会随机给其赋值，而不是0
int x；
```

## 2.5 方法、参数和返回值

许多编程设计语言（C/C++）用**函数**这个术语来描述命名子程序；而在Java中常用**方法**这个术语表示“做某些事情的方式”。虽然只是用词上有区别，不过在Java中还是沿用惯例“方法”比较好。

1. Java的方法决定了一个对象能够接收什么样的消息。方法的基本组成部分：名称、参数、返回值、和方法体

   ```java
   ReturnType methodName(/* Argument list */){
   	/* Method body */
   }
   ```

2. 返回类型描述的是在调用方法之后从方法返回的数据的类型。

3. 参数列表给出了要传给方法的信息和名称。

4. 方法名和参数列表（合称“方法签名”）唯一地标识出某个方法。

5. Java中的方法只能作为类的一部分来创建，方法需要通过对象来调用，同时对象也要能够执行这个方法调用。

6. 通过对象调用方法，需要先列出对象名，紧接着句点，然后是方法名和参数列表。

   ```java
   objectName.methodName(arg1, arg2, arg3);
   ```

7. 假如，方法f()，不带任何参数，返回类型是int，有个名为a的对象，可以通过a调用f()

   ```java
   int x = a.f();
   ```

8. 返回值的类型必须要与x的类型兼容

9. 这种调用方法的行为通常被称为**发送消息给对象**，在上面的例子中，对象是a，消息是f()。面向对象的程序设计通常简单的归纳为“向对象发送消息”

### 2.5.1 参数列表

方法的参数列表指定要传给方法什么样的信息。

1. 这些信息都采用对象的形式，因此，在参数列表中必须指定每个所传递对象的类型及名字。

2. 在Java中，对象的传递都是按值调用，即传递的实际上是引用，假设某个方法接收String为其参数

   ```java
   int storage(String s){
   	return s.length()*2
   }
   ```

3. 此方法告诉我们，需要多少个字节才能容纳一个特定的String对象中的信息。此方法的参数类型是String，参数名是s。一旦将s传递给此方法，就可以把它当作其他对象一样进行处理（可以给它传递消息）。这里的length()方法会返回字符串中包含的字符数。

4. return关键字包含了两方面：首先，它代表“已经做完，离开此方法”。其次如果此方法产生了一个值，这个值要放在return语句的后面。我们可以定义方法返回任意想要的类型，若不想返回任何值，可以使用void关键字

   ```java
   boolean flag(){return true;}
   double naturalLogBase(){return 2.718;}
   void nothing(){return; }
   void nothing2(){}
   ```

## 2.6 构建一个Java程序

### 2.6.1 名字可见性

名字管理对于任何程序设计语言来说，都是一个很重要的问题。

**问题**：如果在程序的某个模块里使用了一个名字，而其他人在这个程序的另外一个模块里也使用了相同的名字，如何区别这两个名字，且防止二者互相冲突呢？

1. 在Java中，采用和Internet中域名的层次命名法相似的一种概念。
2. Java设计者希望程序员反过来使用自己的Internet域名，来包含和发布自己所开发的类库
3. 例如，我的域名是MindView.net，我的应用工具类库就被命名为net.mindview.utility.foibles。反转域名后，句点就用来代表子目录的划分。
4. 这种机制意味着所有文件都能够自动存活它们自己的名字空间呢，而且同一个文件内的每个类都有唯一的标识符。

### 2.6.2 运用其他构件

问题：如果想要在自己的程序里使用预先定义好的类，那么编译器必须知道怎么定位它们。

1. 使用关键字import来准确告诉编译器你想要的类是什么。import指示编译器导入一个包，也就是一个类库。

2. 大多时候，我们使用与编译器附在一起的Java标准类库里的构件。有了这些构件，我们就不必写一长串的反转域名。

   ```java
   import java.unil.ArrayList
   ```

3. 这行代码告诉编译器，我们想使用java的ArrayList类。但是，unil包含了数量众多的类，有时你想使用其中几个，同时又不想逐一声明，这样我们可以使用通配符 “*” 来达到这个目的

   ```java
   import java.unil.*
   ```

### 2.6.3 static关键字

通常来说，当创建类时，就是在描述那个类的外观与行为。除非用new创建那个类的对象，否则，实际上并未获得任何对象，因而无法查看外观和调用行为。

问题：若想为某种特定域分配单一的存储空间，而不去考虑究竟要创造多少对象。另外一种情况，希望某个方法不与包含它的类的任何对象产生关联，也就是说，即使没有创建对象，也能够调用这个方法。

1. static关键字可以满足两方面的需要，当声明一个事物是static时，就意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。

2. 只须将static关键字放在定义之前，就可以将字段或方法设定为static。例如，下面的代码就生成了一个static字段，并对其进行了初始化：

   ```java
   class StaticTest {
   	static int i = 47;
   }
   ```

3. 现在，即使我们创造了两个StaticTest对象，StaticTest.i也只有一份存储空间，这两个对象共享同一个i。

   ```java
   StaticTest st1 = new StaticTest();
   StaticTest st2 = new StaticTest();
   ```

4. 在这里，st1.i和st2.i都指向同一存储空间，因此它们具有相同的值47。

5. 引用static变量有两种方法，如前例所示，可以使用对象去定位它，st1.i；也可以通过类名直接引用

   ```java
   StaticTest.i++;
   ```

6. 其中，++运算符对变量进行递加操作。此时，st1.i和st2.i仍具有相同的值48。

7. 优先使用类名来引用static变量。

8. 静态方法的定义与静态字段类似

   ```java
   class Incrementable{
   	static void increment(){StaticTest.i++}
   }
   ```

9. 当然也可以用Incrementale生成的对象来调用此静态方法

10. static作用于某个字段时，肯定会改变数据创建的方式。不过static作用于方法时，差别却没那么大。

11. static方法最重要的特点在于，不用构造对象就能调用方法，在mian()定义中尤为重要。这个方法是运行一个应用时的入口点。

## 2.7 让我们开始第一个程序吧

最后，让我们编写第一个完整的程序，此程序开始打印一个字符串，然后打印当前日期，这里用到了Java标准库里的Date类。

```java
public class HelloDate {
    public static void main(String[] args){
        System.out.println("Hello, it's: ");
        System.out.println(new Date());
    }
}
```

在每个程序的开头，必须申明import语句，以便引入在文件代码中需要用到的额外类。在这里指出的“额外”，是因为有一个特定的类会被自动导入每一个Java文件中：java.lang（根据Oracle公司提供的JDK文档，可以查询这个类库所包含的全部类的列表）由于java.lang是默认导入到每个Java文件中的，所以它的类全都可以直接使用。不过java.lang中没有Date类，所以必须导入另外一个类库才能使用它。

1. 若不知道某个特定的类在哪个类库，在JDK文档中选择“Tree”，可以看到Java配套提供的每一个类。
2. 选择java.lang，接着选择system类，其中out是一个静态PrintStream对象。
3. 因为是静态的，所以不需要创建任何东西，out对象就已经存在的了，直接使用就行。
4. 但是我们能够向out发送什么消息，这个取决于它的类型PrintStream。
5. public关键字指，这是一个可以由外部调用的方法
6. main()方法的参数是一个string对象的数组，参数名为args，用于存储命令行参数。（不管是否使用，Java中必带）

让我们回过头来看看打印日期的这行代码：

```java
System.out.println(new Date());
```

在这里，传递参数的是一个Date对象，一旦创建完毕，就可以直接将它的值发送给println()，**注意**：这个值原本是存于引用的对象地址，在这里自动转为对象中的String类型。同时，这条语句结束后，Date对象就不再被使用，而垃圾回收器发现这一情况，并在任意时候将其回收。

当然我们还可以用System类来做许多其他的事情

```java
public class ShowProperty {
    public static void main(String[] args){
        System.getProperties().list(System.out);
        System.out.println(System.getProperty("user.name"));
        System.out.println(System.getProperty("java.library.path"));
    }
}
```

main()的第一行将显示从运行程序的系统中获取的所有“属性”，因此它可以向你提供环境信息。list()方法将结果发送给它的参数：System.out。

### 2.7.1 编译和运行

要编译、运行Java程序，需要有一个Java开发环境，目前除了Oracle以外，还有众多的第三方厂商提供开发环境（具体原因参考《深入理解Java虚拟机》）。

1. 安装好JDK后，确保计算机能够找到javac和java这两个可执行文件

2. 配置好运行目录后，在源文件的目录下，依次运行下列命令

   ```java
   javac HelloDate.java
   ```

   ```java
   java HelloDate
   ```

3. 上面的命令依次对应编译和运行

## 2.8 注释和嵌入式文档

Java继承于C/C++的两种注释风格

```java
/* 这是第一种注释
 * 这是一个注释行！
 * 这还是一个注释行1
 */
```

```java
// 这是第二种注释
// 这是一个注释行！
// 这还是一个注释行！
```

### 2.8.1 注释文档

代码文档撰写的最大问题，就是对文档的维护了。

**问题**：每次修改代码时，都需要修改相应的文档，这会成为一件相当乏味的事情。

1. 解决的方法，是将代码同文档“链接”起来。
2. 将所有东西都放在同一个文件内。
3. 使用一种特殊的注释语法来标记文档。
4. 此外还需要一个工具，用于提取那些注释，并将其转换成有用的格式。

javadoc便是用于提取注释的工具，它是JDK安装的一部分。它采用Java编译器的某些技术，查找程序内的特殊注释标签。它不仅解析这些标签的信息，也将毗邻注释的类名或方法名抽取出来。如此，我们可以用最少的工作量，生成相当好的程序文档。

1. javadoc输出的是一个HTML文件，可以用Web浏览器查看，这样，该工具就使得我们只须创建和维护单一的源文件，并能自动生成有用的文档。有了javadoc，就有了创建文档的简明直观的标准。

### 2.8.2 javadoc语法

1. 所有javadoc命令都只能在“/**”注释中出现，通常一样，注释结束语为”\*/“。

2. 使用javadoc的方式主要有两种：嵌入式HTML，或使用“文档标签”。

3. 共有三种类型的注释文档，分别对应注释位置后面的三种元素：类、字段、和方法

   ```java
   /** A class comment*/
   public class Documentation{
   	/** A field comment */
   	public int i;
   	/** A method comment */
   	public void f(){}
   }
   ```

4. 注意，javadoc只能为public（公共）和protectcted（受保护的）成员进行文档注释。private（私有）和包内可访问成员的注释会被忽略掉。

5. 上述代码的输出结果是HTML文件，它与其他Java文档具有相同的标准格式。因此，用户会非常熟悉这种格式，从而方便地导航到用户自己设计的类。输入上述代码，然后通过javadoc处理产生的HTML文件，最后通过浏览器观看生成的结果，这样做是非常值得。

6. **注意**：这里是简化操作，具体使用IDEA下的集成javadoc参照Java规范。

## 2.9 编码风格

Java编程语言编码规定—以前在sun公司的网页上，现在应该在oracle的网页上

具体的规定有

1. 类的命名，需要首字母大写，多个单词要拼在一起（各单词首字母大写，不使用下划线来分隔字母）
2. 方法、字段以及对象的引用名，都需要首字母大小，多个单子拼接时，后续拼接的单词首字母大写

# chapter 03 操作符

在底层，Java中的数据通过操作符来操作的

## 3.1 更简单的打印语句

在Java SE5新增了静态导入（static import），可以创建一个小类库来简化打印语句的编写。

```java
import java.util.*;
import static net.midview.util.Print.*;

public class HelloDate{
	public static void mian(String[] agrs){
		print("Hello, it's: ");
		print(new Date());
	}
}
```

## 3.2 使用Java操作符

操作符接受一个或多个参数，并生成一个新值。参数的形式与普通的方法调用不同，但效果时相同的。

1. 加号和一元的正号（+）
2. 减号和一元的负号（-）
3. 乘号（*）
4. 除号（/）
5. 赋值（=）

操作符作用于操作数，生成一个新值。几乎所有的操作符只能操作“基本类型”。

例外的操作符是“ = ”、“ == ”和“ != ”，这些操作符可以操作所有的对象。

除此以外，String类支持“+”和“+=”。

## 3.3 优先级

当一个表达式中存在多个操作符时，操作符的优先级就决定了各部分的计算顺序。不过并不便于记忆，还是使用括号()规定优先级。

```java
public class Precedence{
	public static void main(String[] args){
		int x = 1, y = 2, z= 3;
		int a = x + y - 2/2 + z;
		int b = x + (y - 2)/(2 + z);
		System.out.println("a = " + a + " b = " + b);
	}
}
```

这两个语句看起来大体相同，但是从输出上可，可看出截然不同的含义。

**注意，**System.out.println()语句中包含“+”操作符。在这种上下文环境中，“+”意味着字符串链接。当编译器观察到一个String后面紧跟一个“+”，而这个“+”后面又紧跟一个非String类型的元素，执行“字符串转换”，就会尝试将这个非String类型的元素转换成String。正如输出中所看到的，它成功地将a和b从int转换为String了。

## 3.4 赋值

赋值使用操作符“=”，它的意思是“取右边的值（右值），将其复制给左边（左值）“。右值可以是任何常数、变量或者表达式（只要能生成一个值）。但左值一定必须是一个明确的、已命名的常量。也就说，必须有一个物理空间可以存储等号右边的值。

1. 对基本数据类型的赋值很简单，基本类型存储了实际的数值，而不是指向一个对象的引用，所以在为其赋值的时候，是直接将一个地方的内容复制到了另外一个地方。例如，对基本数据类型使用a=b，那么b的内容就复制给a。若又修改了a，而b不会受到这个影响。
2. 但是在为对象”赋值“的时候，情况会发生变化，对一个对象进行操作时，我们真正操作的是对象的引用。所以将“一个对象赋值给另外一个对象”，实际是将”引用“从一个地方复制到另一个地方。这意味着假如对一个对象使用c=d，那么c和d都指向原本只有d指向的那个对象。对c或者d的操作，都可能改变原有对象中的内容，从而使c和d指向的对象同时发生变化。

## 3.5 算术操作符

Java的基本操作符和大多数程序设计语言是相同的，其中包括加号（+），减号（-），除号（/），乘号（*）以及取模操作符（%）。整数除法会会直接去掉结果的小位数，而不是四舍五入地圆整结果。

Java中也使用了来自C/C++的简化符号，同时进行运算和赋值操作。这用操作符后紧跟一个等号来表示，它对Java中的所有操作符都适用。例如，要将x加4，并将结果赋值回x，则：x += 4；

1. 如果想随机生成一个数字，可以使用Random类，构造其对象。
2. 如果创建过程中没有传递任何参数，那么Java就会将当前时间作为随机数生成器的种子，并由此在程序每一次执行时都产生不同的输出。
3. 若为了验证结果，保证输出的统一，可以使用固定的种子数。
4. 通过Random类的对象，程序可以生成许多不同类型的随机数种子。做法很简答，只需要调用方法nextInt()和NextFloat()即可。
5. 传递给nextInt()的参数，设置了所产生的随机数的上限，其下限为0，但是这个下限并不是我们想要的，因此它会产生0点可能性，因此我们需对结果做了加1对操作。

## 3.6 自动递增和递减

和C类似，Java提供了大量的快捷运算。这些快捷运算使编码更加方便，同时也使得代码更加容易阅读

1. 递减“ -- ”，意为“减少一个单位”。
2. 递增“ ++ ”，意为“增加一个单位”。
3. 两个操作符各有两种使用方式，通常称为“前缀式”和“后缀式”。前缀式表示“++”操作符位于变量或表达式的前面；而“后缀递增”表示“++”操作符位于变量或表达式的后面。

## 3.7 关系操作符

关系操作符生成的是一个boolean（布尔）结果，它们计算的操作数的值之间的关系。如果关系是真实的，关系表达式会生成true（真）；如果关系不真实，则生成false（假）。关系操作符包括小于（<）、大于(>)、小于或等于（<=）、大于或等于（>=）、等于（==）以及不等式（!=）。等于和不等于适用于所有的基本数据类型，而其他比较符不适用于boolean类型。因为boolean值只能为true和false，“大于”和“小于”没有实际意义。

1. 测试对象的等价性，通常使用equal()，不过equal()默认比较的是引用，而在基础数据类型的Integer包装类中重写了equal()方法，可以直接比较存储的值。
2. 实际上Integer在初始化时，通常在堆区有一个常量池对象（-127～+128），此时的引用直接指向的是常量池的对象，是否使用常量池的对象，取决于是否用new创建（-127～+128）（此处问题的探讨留于深入Java）

## 3.8 逻辑操作符

逻辑操作符“与”（&&）、“或”（||）、“非”（!）能根据参数的逻辑关系，生成一个布尔值（true或false）。

1. 上面三个&&、||、! 操作只可应用于布尔值，不可将一个非布尔值当作布尔值在逻辑表达式中使用。
2. **注意**，如果在String值的地方使用了布尔值，即会执行字符串转换，将布尔值自动转换成适当的文本形式。
3. 短路，当使用逻辑操作符时，会遇到一种“短路”的情况。即一旦能够明确无误地确定整个表达式的值，就不再计算表达式余下的部分了。因此，整个逻辑表达式靠后的部分有可能不会被运算。
4. 可以获得潜在的性能提升

## 3.9 直接常量

一般来说，在程序里使用了“直接常量”，编译器可以准确知道要生成什么样的类型，但有时候却时模棱两可的。如果发生这种情况，必须对编译器加以适当的“指导”，用于直接量的某些字符来额外增加一些信息。

1. 直接常量后面的后缀字符标志了它的类型。L(l)代表long；F(f)代表float；D(d)代表double；
2. 十六进制数适用于所有整数数据类型。
3. 若将一个变量初始化成超出自身表示范围的值（无论这个值是十进制、十六进制、八进制），编译器会给出错误/警告，并进行强转。
4. 在C/C++、Java中，二进制数没有直接常量表示方法。不过有时候二进制形式显示结果将非常有用。听过Integer和Long类的静态方法toBinaryString()可以很容易地实现这一点。
5. 当然，在Java中也有指数计数法，1.39E-43f这样的表达式，E不是自然对数的基数，而是10的幂次。

## 3.10 按位操作符

按位操作符来源于C语言面向底层的操作，在这种操作中经常需要直接操作硬件，设置硬件寄存器内的二进制位。Java的设计初衷是嵌入电视机顶盒内，所以这种面向底层的操作仍被保留了下来。但是，人们可能不会过多的使用到位操作符。（&、｜、^、～）

## 3.11 移位操作符

移位操作符操作的对象也是二进制的“位”，移位操作符只可用来处理整数int类型（基本类型的一种）。

1. 左移操作符（<<）能按照操作符指定的位数，将操作符左边的操作数向左移动（在低位补0）。
2. “有符号”右移操作符（>>）则按照操作符右侧指定的位数，将操作符左边的操作数向右移动。“有符号”右移位操作符使用“符号拓展”：若符号为正，则高位插入0；若符号为负，则在高位插入1。
3. 在Java中新增了一种“无符号”右移操作符（>>>），它使用“零拓展”，无论正负，都在高位插入0。
4. 如果对char、byte或者short类型的数值进行移位处理，那么在进行移位之前，它们会被转成int类型，并且得到的结果也是int类型的值。
5. 在操作符右边的数值，只有**低五位**才有用，这样可以防止我们移位超过int型值所具有的位数（2的5次方是32）
6. 在long类型中的数值，进行移位处理后，得到的还是long，同样只有右端数值的低六位才有用。
7. “移位”可与“等号”组合使用，此时，操作符左边的值会移动由右边的值指定的位数。

## 3.12 三元操作符 if-else

三元操作符也称条件操作符，它有三个操作数。不过它确实属于操作符的一种，因为它最终也会生成一个值，这与if-else语句是不同的。

1. 表达式：boolean-exp ？value0 ： value1
2. 如果表达式的结果为true，就计算value0，而且这个计算结果也就是操作符最终产生的值。
3. 如果表达式的结果为false，就计算value1，同样这个结果作为操作符最终产生的值。

具体使用if-else还是三元运算符，还得看场合。

## 3.13 字符串操作符 + 和 +=

这个操作符在Java中有特殊的用途：连接不同的字符串。这一点已经在前面的例子中展示过了。尽管与

+和+=传统的使用方式不太一样，但我们还是很自然地使用这些操作符来做这件事情。（C++与C#中引入了操作符重载，虽然Java更易于实现，但是仍过于复杂，因而Java没有此项功能—Java SE5、6）

1. 字符串操作符有一些有趣的行为。如果表达式以一个字符串起头，那么后续所有操作数都必须是字符串型。

   ```java
   int x = 0;
   System.out.println("" + x);
   /*Output:
   0 
   */
   ```

2. 上述代码以一个空的字符串，跟上“+”，在接基本类型，这样的操作，有助于直接显示相关基本类型中存储的值，而不用调用更加麻烦的显示方法（例如Integer.toString()来执行字符串转换）

## 3.14 使用操作符时常犯的错误

有时，我们会对表达式的计算有些不确定

```c
while(x = y){
	//...
}
```

这里很明显需要使用的是“==”，而不是赋值，在C/C++中，如果y是一个非零值，就会得到一个无穷的循环，但是在Java中，编译器会期望得到一个布尔值，即Java并不会自动将int数值转换成boolean值，所以在编译时，会抛出一个编译时错误，从而阻止我们进一步取运行程序。所以这种错误在Java中永远不会出现。（不过万一x，y都是布尔值，就很尴尬了）

除了上面的问题，还有一个就是需要使用与、或、非这样的逻辑运算时，按位的还是逻辑的，若是用错了，在C/C++中可能可以运行，不过Java同样会在编译时报错，因为Java不允许我们随便把一种类型当作另一种类型来使用。

## 3.15 类型转换操作符

类型转换（cast）的原意是“模型铸造”。在适当的时候，Java会将一种数据类型自动转换成另一种。例如，我们为某浮点变量赋以一个整数值，编译器会自动将int转换成float。

1. 类型转换运算允许我们显示地进行这种类型的转换，或者在不能自动转换的时候进行强制类型转换。

2. 想要执行类型转换，需要将希望得到的数据类型置于圆括号内，并放在要进行类型转换的值的左边。

   ```java
   public class Casting{
   	public static void main(String[] args){
   		int i = 200;
   		long ing = (long)i;
   		lng = i;
   		long lng2 = (long)200;
   		lng2 = 200;
   		// A "narrowing conversion"
   		i = (int)lng2;
   	}
   }
   ```

3. 如上所示，既可对数值进行类型转换，亦可对变量进行类型转换。

4. 注意，**拓展转换**（widening conversion）是安全的，但是**窄化转换**（narrowing conversion）是不安全的，必须要显示地进行强制类型转换。

5. Java允许我们把任何基本数据类型转换成别的基本数据类型。但boolean型除外。同样，“类”这样的数据类型也不能进行的类型转换。

6. 不过为了将一个类转换成另外一种，需要采用特殊的处理方法（对象可以在其所属类型的类族之间进行类型转换，多态？）

### 3.15.1 截尾和舍入

在执行窄化转换时，必须注意截尾与舍入的问题。

**问题**：如果将一个浮点数转换成整型值，Java会如何处理呢？即将29.7转换成int，结果是30还是29？

```java
public class CastingNumbers{
	public static void main(String[] args){
		double above = 0.7, below = 0.4;
		float fabove = 0.7f, fbelow = 0.4f;
		print("(int)above: " + (int)above);
		print("(int)below: " + (int)below);
		print("(int)fabove: " + (int)fabove);
		print("(int)fbelow: " + (int)fbelow);
	}
} /* Output
(int)above: 0
(int)below: 0
(int)fabove: 0
(int)fbelow: 0
*/
```

1. 有上述代码，可得，将float或double转型为int时，总是对该数字执行截尾。如果想要得到舍入的结果，就需要使用java.lang.Math中的round()方法：
2. round()是java.lang的一部分，使用时不需额外的导入。

### 3.15.2 提升

1. 如果对基本数据类型执行算数运算或按位运算，只要类型比int小，就会自动转换成int。这样一来，最终生成的结果就是int类型。
2. 如果想要把结果赋值给较小的类型，就必须使用类型转换（窄化转换可能会丢失信息）
3. 通常表达式中，出现的最大数据类型，就决定了表达式最终结果的数据类型。

## 3.16 Java没有sizeof

1. 在C/C++中，sizeof()操作符可以告诉你，为数据项分配的字节数。
2. 在C/C++中，需要sizeof()的最大原因是为了移植。不同的数据类型在不同的机器上可能有不同的大小，所以在进行一些与存储空间有关的运算时，程序员必须获悉那些类型具体有多大。
3. 因为Java不需要sizeof()操作符来满足这方面的需要，因为所有数据类型在所有机上中的大小都是相同的。
4. 我们不必考虑移植的问题—已经被设计在语言中了。

# chapter 04 控制执行流程

就像有知觉的生物一样，程序必须在执行过程中控制它的世界，并做出选择。在Java中，你要执行控制语句来做出选择。

## 4.1 true和false

1. 所有条件语句都利用条件表达式的真或假来决定执行路径。
2. 本章前面介绍的所有关系操作符都可以拿来构造条件语句。
3. **注意，**Java不允许我们使用一个数字作为布尔值，虽然这在C/C++中是允许的。
4. 比如if(a)是不允许的，需要换成if(a!=0)。

## 4.2 if-else

if-else语句是控制流程的最基本形式，else是可选的。

```java
if(Boolean-expression){
	statement
} else{
	statement
}

```

## 4.3 迭代

1. while、do-while和for用来控制循环，有时将它们划分为迭代语句。

2. 语句会重复执行，知道起控制作用的布尔表达式得到“假”的结果为之。

   ```java
   while(Boolean-expression){
   	statement
   }
   ```

3. while在循环刚开始时，会计算一次布尔表达式的值；而在语句的下一次迭代开始前会再计算一次。

4. 不过do-while有些不同，它会先执行一次语句(statement)，然后再计算布尔表达式的值，哪怕是false。

   ```java
   do{
   	statement
   } while(Boolean-expression)
   ```

5. for循环需要在第一次迭代之前进行初始化，迭代前还需要进行条件判断，且在每一次迭代结束时，都要进行某种形式的“步进”。

   ```java
   for(initialization; Boolean-expression; step) {
   	statement
   }
   ```

6. 逗号操作符(,)与逗号分隔符(;)。Java里唯一用到逗号操作符的地方就是for循环的控制表达式。通过使用逗号操作符，可以在for语句内定义多个变量，但它们必须具有相同的类型。在控制表达式的初始化和步进控制部分，可以使用一系列的逗号分隔的语句(;)，那么语句均会独立执行。

   ```java
   public class CommaOperator{
   	public static void main(String[] args){
   		for(int i = 1, j = i + 10; i < 5; i++, j = i * 2) {
   			System.out.println("i = " + i + " j = " + j);
   		}
   	}
   }
   ```

7. for语句中的int定义涵盖了i和j，在初始化部分实际上，可以拥有任意数量的具有相同类型的变量定义。

8. 逗号分隔符(,)还可以用于分隔函数的不同参数。

## 4.4 Foreach语句

1. JavaSE 5引入了一种新的更加简洁的for语句用于数组和容器，即foreach语法。

2. 不必创建int变量去对由访问项构成的序列进行计数，foreach将自动生成每一项的引用(副本)。

   ```java
   for(float x : f) {
   	statement
   }
   ```

3. 这条语句定义了一个float类型的变量，继而将每一个f的元素赋值给x。

4. 任何返回一个数组的方法都可以使用foreach。例如，String类有一个方法toCharArray()，它返回一个char数组，因此很容易像下面这样，迭代输出在字符串里面的所有字符：

   ```java
   public class ForeahcString{
   	public static void mian(String[] args) {
   		foreach(char c : "A African Swallow".toCharArray)(){
   			System.out.print(c + " ");
   		}
   	}  
   }
   ```

5. foreach不仅在录入代码时可以节省时间，更重要的是，它阅读起来更加容易。

## 4.5 return

1. 在Java中有许多个关键词表示无条件分支，它们只是表示这个分支无需要任何测试即可发生。
2. 这些关键词包括return、break、continue
3. return关键词有两个用途：指定一个方法返回什么值；另一方面会结束当前方法，返回那个指定的值。
4. 如果在返回void的方法中没有return方法，那么在该方法的结尾处会有一个隐式的return。

## 4.6 break和continue

1. 在任何迭代语句的主体部分，都可以用break和continue控制循环的流程。
2. 其中，break用于强行退出循环，而不用执行剩余的语句。
3. 而continue则停止执行当前迭代环节，然后退回到循环起始处，开始下一次迭代。

## 4.7 臭名昭著的goto

1. 编程语言一开始就有goto关键词了。事实上，goto起源于汇编语言的程序控制：”若条件A成立，则跳到这里；否则跳到这里“。
2. goto语句是在源码级上的跳转，招致了不好的声誉。
3. 对于这个问题，采取权衡的方式，在合适的情况下，较少的使用goto，毕竟goto还是组织控控制流程的最佳手段。

## 4.8 switch

1. switch有时被划归一种选择语句。根据整数表达式的值，switch语句可以从一系列代码中选出一段去执行。

   ```java
   switch(integral-selector) {
   	case integral-value1:
   		statement;
   		break;
   	case integral-value2:
   		statement;
   		break;
   	case integral-value3:
   		statement;
   		break;
   	//...
   	default:statement;
   }
   ```

2. 其中，integral-selector（整数选择因子）是一个能够产生整数值的表达式。

3. switch能够将这个表达式的结果与每个integral-value（整数值）相比较。

4. 若发现相符的，就会执行对应的语句（单一的或者多条的，其中并不需要花括号）。

5. 若没有发现相符的，就执行default（默认）的语句。

6. 在上面的定义中，大家会注意到每个case均以一个break结尾，这样可使执行流程跳转至switch主体的末尾。

7. braek是可选的，如果省略break，会继续执行后面的case语句，直到遇到一个break。

switch语句是实现多路选择（也就是说从一系列执行路径中挑选一个）的一种干净利落的方法。

1. 但它要求使用一个选择因子，并且必须是int或char那样的整数值。
2. 对于非整数类型，必须使用一系列的if语句。

# chapter 05 初始化与清理

**随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。**

初始化与清理正涉及安全的两个问题。许多C程序的错误原语程序员忘记初始化变量。特别是在使用程序时，如果用户不知道如何初始化库的构件（或者是用户必须进行初始化其他东西），更是如此。

清理也是一个特殊问题，当使用完一个元素时，它对你也就不会有什么影响了，所以很容易把它忘记。这样一来，这个元素占用的资源就会一直得不到释放，结果是资源（尤其是内存）用尽。

C++引入构造器（constructor）的概念，这是一个在创建对象时，被自动调用的特殊方法。Java也采用了构造器，并额外提供了“垃圾回收器”。对于不再使用的内存资源，垃圾回收器能自动将其释放。本章将讨论初始化与清理的相关问题，以及Java对它们的支持。

## 5.1 用构造器确保初始化

可以假象为编写的每个类都定义一个initialze()方法。该方法的名称提醒你在使用其对象之前，应该先调用initialize()。然后，这同时意味着用户必须记得自己去调用此方法。在Java中，通过提供构造器，类的设计者可确保每个对象都会得到初始化。

**问题**：如何命名这个方法，第一，所取的名字可能会与类的某个成员名称冲突；第二，调用构造器是编译器的责任，所以必须让编译器知道应该调用哪个方法。

1. C++采用的解决方法简单也符合逻辑，Java也采用了这个方案：构造器与类名相同。

   ```java
   class Rock {
   	Rock() {
   		System.out.print("Rock");
   	}
   }
   
   public class SimpleConstructor{
   	public static void mian(String[] args){
   		for(int i = 0; i < 10; i++) {
   			new Rock();
   		}
   	}
   }
   ```

2. new Rock()将会为对象分配空间，并调用相应的构造器。这确保了在我们能够操作对象之前，它已经初始化了。

3. 不接受任何参数的构造器叫做**默认构造器（无参构造器）**，不过同其他方法一样，构造器也能和其他方法一样，构造器也能带有形式参数，以便于指定如何创建对象。

   ```java
   class Rock {
   	Rock(int i) {
   		System.out.print("Rock" + i + " ");
   	}
   }
   
   public class SimpleConstructor{
   	public static void mian(String[] args){
   		for(int i = 0; i < 10; i++) {
   			new Rock(i);
   		}
   	}
   }
   ```

4. 有了构造器形式参数，就可以在初始化对象时提供实际参数。

5. 构造器有助于减少错误，并使代码易于阅读。从概念上看，“初始化”和“创建”是彼此独立的。

6. 不过在上面的代码中，我们却找不到对initialize()方法的明确调用。

7. 在java中，，“初始化”和“创建”是捆绑在一起的，两者不能分离。

构造器是一种特殊类型的方法，因为它**没有返回值**。这与返回值为空(void)明显不同，对于空返回值，尽管方法本身不会自动返回什么，但仍可选择让它返回别的东西。构造器则不会返回任何东西。

1. new表达式确实返回了新建对象的引用，但构造器本身没有返回任何值。

## 5.2 方法重载

任何程序设计语言都具备一样重要的特性，就是对名字的运用。当创建一个对象时，也就给对象分配到的存储空间取了一个名字。所谓方法则是给某个动作取的名字。通过使用名字，我们可以引用所有的对象和方法。

1. 在日常生活中，相同的词可以表达多种不同的含义—清洗衬衫、清洗车、清洗狗。
2. 而不是—以衬衫的方式洗衬衫、以洗车的方式洗车、以洗狗的方式洗狗。
3. 大多数人类的语言都有很强的“冗余”性，漏掉几个词，仍可以推断语义。

在C中，要求为每个方法都提供独一无二的标识符。

**问题**：在Java(C++)里，构造器是强制重载方法名的另一个原因。既然构造器的名字已经由类名所决定，就只能有一个构造器名。那么想要多种方式创建一个对象该怎么办呢？

1. 假如我们需要创建一个类，既可以用标准方式进行初始化，也可以从文件里读取信息进行初始化。
2. 这就需要两个构造器：一个无参构造器，一个可以取字符串（文件名称）作为形式参数。
3. 由于都是构造器，所以它们必须相同的名字，即类名。
4. 为了让方法名相同而形式参数不同的构造器同时存在。必须用到**方法重载**。
5. 尽管方法重载是构造器所必须的，但它亦可用于其他的方法，且用法同样简便。

### 5.2.1 区方方法重载

**问题**：要是几个方法有相同的名字，Java如何才能知道你指的是哪一个？

其实规则很简单，每个重载的方法都必须有一个独一无二的参数列表。

### 5.2.2 涉及基本类型的重载

基本类型能从一个“较小的”类型自动提升至一个“较大”的类型。此过程一旦牵扯到重载，可能会造成一些混淆。

1. 现要传入一个int，值为5，编译器会寻找某个重载方法接受int型参数，它就会被调用。
2. 如果传入的数据类型（**实际参数类型**）小于方法中声明的**形式参数类型**，实际数据类型就会提升。
3. char型略有不同，如果无法找到恰好接受char参数的方法，就会把char直接提升至int型。

**问题**：如果传入的实际参数类型大于重载方法声明的形式参数，会出现什么情况？

方法可接受较小的基本类型作为参数，如果传入的**实际参数较大**，就需通过类型转换来执行**窄化转换**。如果不这样做，编译器就会报错。

## 5.3 默认构造器

默认构造器（由名无参构造器）是没有形式参数的，它的一个作用是创建一个“默认”对象。如果你写的类中没有构造器，则编译器会自动帮你创建一个默认构造器。

**注意**：如果已经定义了一个构造器（无论是否有参数），编译器就不会帮你自动创建默认构造器。

## 5.4 this关键字

**问题**：如果有同一类型的两个对象，分别是a和b。我们想知道，如何才能让这两个对象都能调用peel()方法？

```java
class Banana{
	void peel(int i){
		//..
	}
}

public class BananaPeel{
	public static void mian(String[] args){
		Banana a = new Banana();
		Banana b = new Banana();
		a.peel(1);
		b.peel(2);
	}
}
```

1. 只有一个peel()方法，它如何知道被a还是b调用了呢？

2. 为了简洁方便，面向对象的语法—“给对象发消息”，编译器做了一些幕后的工作。

3. 编译器将“所操作对象的引用”作为第一个参数传递给peel()。所以上述两个方法的调用就变成了这样。

   ```java
   Banana.peel(a, 1);
   Banana.peel(b, 2);
   ```

4. 当然，这是内部的事情，不能这样写代码

5. 我们希望在方法的内部获得对当前对象的引用。但这个引用是编译器“偷偷”传入的，**没有标识符可用**！

6. 为此，有个专门的关键字：**this**，该关键字只能在方法的内部使用，表示对“调用方法的那个对象”的引用。

7. 当然，一般不会直接添加this，只有需要明确指出对当前对象的引用时，才需要用this关键字。

8. 例如，当需要返回对当前对象对引用时，就常常在return语句里写。

   ```java
   public class Leaf{
   	int i = 0;
   	Leaf increment() {
   		i++;
   		return this;
   	}
   	void print(){
   		System.out.println("i = " + i);
   	}
   	public static void main(Stirng[] args) {
   		Leaf x = new Leaf();
   		x.increment().incremennt().increment().pint();
   	}
   } /* Output
    i = 3
    */
   ```

9. Increment()通过this关键字返回了对当前对象的引用，所以很容易在一条语句里对同一个对象执行多次操作。

### 5.4.1 在构造器中调用构造器

this几种用法

1. 通常情况，this指“当前的对象”，本身表示对当前对象的引用。
2. this()，这里this添加了参数列表，此时this将产生对符合此参数列表的某个构造器的明确调用。
3. this用逗点指示，当前需要发给此对象的消息。

### 5.4.2 static的含义

1. static方法就是没有this的方法。
2. 在static方法的内部无法调用非静态的方法
3. 不过在非静态方法中可用调用static方法
4. 可以在没有创建对象情况下，通过类来直接调用静态方法。（最主要的用法）
5. Java禁用全局方法，不过我们可以在类置入static方法来访问其他的static方法和static字段。
6. 有人认为static方法不是面向对象的，因为它们具有全局函数的语义。

### 5.5 清理：终结处理和垃圾回收

程序员都了解程序初始化的重要性，但常常会忘记同样重要的清理工作。

1. Java有垃圾回收器，负责回收无用对象占据的内存资源。
2. 但也有特殊情况，假设我们的对象（并非由“new”构造）获得了一块特殊的内存区域，由于垃圾回收器只知道释放那些经由new分配的内存，所以它不知道如何释放这块特殊的内存。
3. 为了应对这样的情况，Java允许在类中定义一个finalize()方法。
4. 假定的“工作原理”：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。

C++中的**析构函数**，用于销毁对象必须用到此函数，为了不与Java混淆概念，牢记以下**原则**：

1. 对象可能不被垃圾回收。
2. 垃圾回收并不等于析构。

Java未提供“析构函数”或相似的概念，要做类似的清理工作，必须自己手动创建一个执行清理工作的普通方法。

1. 例如，假设某个对象在创建过程中会将自己绘制到屏幕上，如果不是明确地从屏幕上将其擦出，它将永远得不到清理。
2. 如果在finalize()里加入某种擦出功能，当“垃圾回收”发送时，finalize()得到了调用，图像就会被擦出。
3. 当然，要是垃圾回收没有发生，则图像会一直保留下来。

### 5.5.1 finalize()的用途何在

第3点**原则**：垃圾回收只与内存有关

也就是说，使用垃圾回收器的唯一原因就是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说（尤其是finalize()方法），它们必须同内存及其回收有关。

1. 无论对象如何创建，垃圾回收器会负责释放对象占据的所有内存。
2. **特殊情况**，通过创建对象以外的方式，为对象分配了存储空间，需要使用finalize()方法。
3. 在分配内存中，可能使用了“**本地方法**”（指C/C++的非Java代码）
4. 在C中会使用malloc()函数分配存储空间，然后必须使用free()来释放空间
5. 因此在Java中使用了相关的本地方法后，需要使用finalize()来调用本地方法的free()函数。

### 5.5.2 必要的清理工作

**问题**：Java虽然使用垃圾回收器可以帮助我们自动释放对象的内存，但是它不一定保证会发生。

**原因**：如果Java虚拟机们并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存的。

**方案**：如果想要执行必要的清理，虽然没有C++中的析构函数，但是Java中也有类似的方法，来手动清理。

### 5.5.3 终结条件（需要进一步深入*）

1. 由于finalize()方法是调用本地方法来释放内存，因而不建议多使用此函数。
2. 既然不能指望finalize()，必须创建其他的“清理”方法，并且明确地调用它们。
3. 对于不需要的对象，即需要清理掉对象，应该处于某种状态，可以安全的释放。
4. 例如，对象代表了一个打开的文件，在对象被回收前程序员应该关闭这个文件。
5. 因此，只要对象中存在没有被适当清理的部分，程序就存在很**晦涩的缺陷**。
6. 因此，finalize()可以用于**验证**终结条件。

### 5.5.4 垃圾回收器如何工作

在以前的程序语言中，在堆上分配的代价十分高昂，因此读者自然会会觉得Java中所有对象（基本类型除外）都在堆上分配的方式也非常高昂。

1. 但是，垃圾回收器对于提高对象的创建速度，却有明显提升
2. Java在堆上使用“堆指针”来分配对象的存储空间，可以达到栈上的分配速度。
3. **原因**：垃圾家回收器释放对象的同时，会重新排列剩余对象的存储位置。使其紧密连接。

**引用计数**

1. 每个对象都有一个引用计数器。
2. 当有引用连接至对象时，引用计数加1。
3. 当引用离开作用域，或者引用置位null，引用计数减1。
4. 垃圾回收器会在含有全部对象的列表上遍历，当发现某个对象的引用计数为0时，就会释放其占用的空间。
5. **缺陷**：当对象之间存在循环引用，可能会出现“对象应该被回收，但引用计数却不为零”。

**从堆栈和静态存储区开始，遍历所有的引用。**

1. 发现每个引用，及其所引用的对象，然后是此对象包含的所有引用。
2. 解决“交换自引用的对象组”的问题。

**自适应的垃圾回收计数**

1. 找到存活的对象（取决于不同虚拟机的实现）
2. **停止-复制(stop-and-copy)**，先暂停程序的运行，然后将所有存活的对象从当前堆复制到另一个堆，没有被复制的全是垃圾。
3. 当对象复制到新堆时，它们是一个挨着一个的，所以新堆保持紧凑排列。
4. 然后可按简单的堆指针移动，快速分配存储空间了。
5. **缺陷**：对这种所谓的“复制式回收器”，效率低下有两个原因。首先需要两个堆，在两个堆之间来回倒腾。从而维护比实际需要的多一倍空间。其次的问题是复制，程序进入稳定状态后，只会有少量的垃圾，尽管如此，复制式回收器仍然会将所有的内存自一处复制到另一处。
6. **解决方案**：第一个是将堆中分出几个大块内存，复制动作在这些块中进行。第二个是自适应模式的切换，如果没有新垃圾产生，切换到“标记-清扫”方式。

### 5.5.5 Java虚拟机的附加技术

1. **加载器**上的“**即时(Just-In-Time，JIT)**”编译技术。这种技术可以把程序全部或部分翻译成本地机器码（本来是Java虚拟机的工作），程序运行速度得以提升。
2. 当需要装在某个类（通常在为该类创建第一个对象）时，编译器会先找到.class文件。
3. 然后将该类的字节码装入内存。
4. 此时，有两种方案可选。
5. 一种是让即时编译器编译所有代码。不过这样有两个缺陷：这种加载动作散落到整个程序生命周期内，累加起来要花更多的时间；并且会增加可执行代码的长度。
6. 另一种是惰性评估(lazy evaluation)，即即时编译器只有在必要的时候才编译代码。在Java HotSpot技术就采用了类似的方法，代码每次被执行都会做一些优化，所以执行的次数越多，它的速度越快。

## 5.6 成员初始化

Java尽力保证：所有变量都在使用前都能得到恰当的初始化。对于**方法的局部变量**，Java以编译时错误的形式来贯彻这种保证。

```java
void f() {
	int i;
	i++; // Error -- i not initialized
}
```

不过在类的数据成员（即字段）是基本类型，情况就有所不同。类的每个基本数据类型成员保证都会有一个初始值。

### 5.6.1 指定初始化

1. 在定义类成员变量的地方为其赋值
2. 可以直接给值，还直接调用下面的方法进行赋值

## 5.7 构造器初始化

可以构造器来进行初始化。即在运行时刻，可以调用方法或执行某些动作来确定初值，这为编程带来了更大灵活性。不过**注意**一点：无法阻止自动初始化的进行，它将在构造器被调用之前发生。

### 5.7.1 初始化顺序

在类的内部，变量定义的先后顺序决定了初始化的顺序。

### 5.7.2 静态数据的初始化

无论创建多少个对象，静态数据都只占用一份存储区域。

1. static关键字不能应用于局部变量，它只能作用于域。
2. 如果一个域是静态的基本类型域，且没有初始化，那么它就会获得基本类型的标准初值。
3. 如果它是一个对象引用，那么它的默认初始化值就是null。

### 5.7.3 显示的静态初始化

Java允许多个静态初始化动作组织成一个特殊的“静态子句”（也成**静态块**）

```java
public class Spoon{
	static int i;
	static {
		i = 47;
	}
}
```

于其他的静态初始化动作一样，这段代码只执行一次：当首次生成这个类的一个对象时，或者首次访问属于那个类的静态数据成员时（即便从未生成过那个类的对象）。

### 5.7.4 非静态实例初始化

Java中也有被称为实例初始化的类似语法，用来初始化每一个对象的非静态变量。与静态初始化块一样，只不过少了static关键字。

## 5.8 数组初始化

数组只是相同类型的、用一个标识符名称封装到一起的一个对象序列或者基本数据类型序列。数据通过方括号下标操作符[]来定义和使用。要定义一个数组，只需要在类型名后加上一对方括号。

```java
int[] a1;
```

方括号也可以置于标识符后面；

```java
int a1[];
```

两种格式的含义是一样的。

1. 对于数组，初始化的动作可以出现在代码的任何地方，但也可以使用一种特殊的初始化表达式，它必须在创建数组的地方出现(等价于使用new)将由编译器负责。例如：

   ```java
   int[] a1 = {1, 2, 3, 4, 5};
   ```

2. 为什么要在没有初始化的时候，定义一个数组的引用呢？

   ```java
   int[] a2;
   a2 = a1;
   ```

3. 在Java中，可以将一个数组赋值给另一个数组。其实真正做的只是复制了一个引用。

4. 所有数组（无论它们的元素是对象还是基本类型）都有一个固定成员，可以通过它获悉数组内包含了多少个元素，但不能对其修改。这个成员就是length。

5. 与C/C++类似，Java数组计数也是从第0个元素开始，所以能使用下标来访问的最大数是length-1。

6. 如果在编写程序的时候，不知道数组里有多少个元素，可以用Random.nextInt()随机给一个。

   ```java
   Random rand = new Raddom(47);
   int[] a = new int[rand.nextInt(20)]
   ```

7. 如果创建了一个非基本类型的数组，那么你就创建了一个**引用数组**。数组中存放的都是对象引用。

8. 如果只是分配引用数组的空间，没有初始化，则会在引用数组中存放的都是null。

9. 最后引入一种特别的，初始化数组的方式

   ```java
    				Integer[] a = {new Integer(1), new Integer(2), 3};
           Integer[] b = new Integer[]{new Integer(1), new Integer(2), 3};
           System.out.println(Arrays.toString(a));
           System.out.println(Arrays.toString(b));
   ```

### 5.8.1 可变参数列表

上面的第二种初始化数组的方式提供了一种方便的语法来创建对象并可调用方法。

如果不知道具体的**参数个数及参数类型**，可使用Object数组为参数的方法，原因在于所有的类都继承于Object。

```java
public class Test {
    public static void main(String[] args) {
        printArray(new Object[]{"one", "two", "three"});
        printArray(new Object[]{1, 2, 3});
        printArray(new Object[]{new Integer(47), new Float(3.14)});
        printArray(new Object[]{new A(), new A()});
    }

    static void printArray(Object[] args){
        for (Object obj : args
             ) {
            System.out.print(obj +" ");
        }
        System.out.println();
    }
}

class A{}
```

1. 可以看到，不知道具体的类型或者个数，就先存储在Object数组中，然后再调用可接受Object数组类型的方法，对其进行遍历。

2. 如果不是Java标准库里的类，直接使用print()方法打印出来的是类名及一串十六进制数。可重写toString()方法来解决这个问题。

3. 以上代码出现在Java SE5之前，现在我们可以使用可变参数列表，而不用在传递前先给各种类型变量进行装载到Object数组中了。

   ```java
     public static void main(String[] args) {
           printArray("one", "two", "three");
           printArray(1, 2, 3);
           printArray(new Integer(47), new Float(3.14));
           printArray(new A(), new A());
       }
   
       static void printArray(Object...args){
           for (Object obj : args
                ) {
               System.out.print(obj +" ");
           }
           System.out.println();
       }
   ```

4. 有了可变参数，就不用再显式地编写数组语法了，当你指定参数时，编译器实际上会为我们去填充数组。我们获得的仍然是一个数组，这也就是为什么还能使用pirnt()进行数组迭代

5. 在**参数化类型（泛型）**的语法结构中，对上面两段代码也如下更改，这样可以保证传入的数据类型不必向上转型

   ```java
   public class Test {
       public static void main(String[] args) {
           printArray2("one", "two", "three");
           printArray2(1, 2, 3);
           printArray2(new Integer(47), new Float(3.14));
           printArray2(new A(), new A());
       }
   
       static  <T> void printArray2(T...args){
           for (T obj : args
           ) {
               System.out.print(obj +" ");
           }
           System.out.println("the length of this args is: " + args.length);
       }
   }
   
   class A{}
   ```

## 5.9 枚举类型

Java SE5中添加了一个看似很小的特性，即enum关键字，它使得我们在需要群组并使用枚举类型集时，可以很方便地处理。

```java
public class Test {
    public static void main(String[] args) {
        Spiciness howHot = Spiciness.MEDIUM;
        System.out.println(howHot);
    }
}

enum Spiciness{
    NOT, MILD, MEDIUM, HOT, FLAMING
}
```

1. 枚举类型的实例时常量，因此按照命名惯例，它们都用大写字母表示（多个单词用下划线分隔）。

2. 使用enum时，需要创建一个该类型的引用，并将其赋值给某个实例。

3. 创建enum时，编译器会自动添加一些有用的特性。例如，它会创建toString()方法。

4. Static  values()方法会按照enum常量声明的顺序，产生又这些常量值构成的数组。

   ```java
   for (Spiciness s : Spiciness.values()) {
               System.out.println(s + ", ordinal " + s.ordinal());
           }
   ```

5. **enum还有一个非常实用的特性，也就是它可以在switch中可用。**

# chapter 06 访问权限控制

**访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关**

1. 所有优秀的作者，包括编写软件的程序员，都清楚作品的某部分直至重新创作的时候才会变得完美，有时甚至要反复重写多次。
2. 重写代码也称重构，使它变得更可读、更易于理解，并因此更具可维护性，这正是重构的原动力之一。
3. 但在这种修改和完善代码的愿望之下，也存在着巨大的压力。通常总是会有一些消费者（客户端程序员）需要你的代码在某些方面保持不变。
4. 但是你想改变代码，而它们却想保持不变，由此而产生了在面向对象设计中需要考虑的一个基本**问题**：如何把变动的事物与保持不变的事物区分开来。
5. 类库的消费者必须依赖于他所使用的那部分类库，并且能够知道如果类库出现了新版本，他们并不需要改写代码。
6. 从另外一个方面来说，类库的开发者必须有权限进行修改和改进，并确保客户端代码不会因为这些改动而受到影响。

**解决**：Java为解决这一问题，提供了访问权限修饰词，以供类库开发人员向客户端程序员指明哪些是可用的，哪些是不可用的。(public > protected > 包访问权限（没有关键词）> private)

## 6.1 包：库单元

包内含有有一组类，它们在单一的名字空间下被组织在了一起。

**原则**：package和import关键字允许你做的，是将单一的全局名字空间分开，使得无论多少人用Internet和Java开始编写类，都不会出现名称冲突的情况。

## 6.2 Java访问权限修饰词

包访问权限：不提供任何访问权限修饰词，则意味着是“包访问权限”

1. 意味着当前包中的所有类对那个成员都有访问权限，但对这个包之外的所有类，这个成员是private的。
2. 同样，对于类中的成员也是如此，只有类可访问也是不够的，字段和方法也需要public和默认包访问权限。

public：接口访问权限

1. 使用关键字public，就意味着public之后紧跟着的成员声明自己对每个人都是可用的，尤其是使用类库的客户端程序员。

private：无法访问

1. 意味着，除了包含该成员的类，其他任何类都无法访问这个成员。
2. 其实在设计之初时，对于访问权限，我们常常使用默认的包访问权限，因为客户端程序员无法访问默认访问权限的成员。因此，只需考虑哪些成员是可公开(public)的即可。
3. 然而，在多线程环境下会尤为重要。

protected：继承访问权限

1. 基类的创建者会希望某个特定的成员，把它的访问权限赋予给派生类，而不是所有类。
2. 如果创建了一个新包，并继承另一个包中的类，那么唯一可以访问的成员就是源包的public成员。
3. 如果在同一个包内执行继承工作，就可以操作所有的拥有包访问权限的成员。

## 6.3 接口和实现

访问权限的控制常被称为是**具体实现的隐藏**。把数据和方法包装进类中，以及具体实现的隐藏，常共同称为**封装**。其结果是一个带有特征和行为的数据类型。

1. 出于两个原因，访问权限控制将权限的边界划分在了数据类型的内部。
2. 第一个原因是要设定，客户端程序员可以使用和不可以使用的界限。
3. 第二个原因，将接口和具体实现进行分离。

**接口是指客户端程序员可以访问并发送消息的成员。**

## 6.4 类的访问权限

在Java中，访问权限修饰词也可以用于确定类库中的哪些类，对于该库的使用者是可用的。如果希望某个类可为某个客户端程序员所用，就可以使用关键字public作用于整个类的定义。

1. 每个编译单元（文件）都只能有一个public类。
2. public类的名称必须与含有该编译单元的文件名相同。
3. 当然，不带public类的编译单元也存在。
4. **注意**，类既不可以是private的，也不可以是protected。
5. 默认则是包访问权限。

# chapter 07 复用类

**复用代码是Java众多引人注目的功能之一。但想要称为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它必须能够做更多的事情。**

## 7.1 组合语法

只需将对象引用置于新类中即可。例如，假设你需要某个对象，它要具有多个String对象、几个基本数据类型，以及另外一个类的对象。对于非基本类型的对象，必须要将其引用置于新的类中，但是可以直接定义基本类型数据：

## 7.2 继承语法

继承是所有OOP语言和Java语言不可缺少的组成部分。当创建一个类时，总是在继承，因此，除非明确指出要从其他类中继承，否则就是在隐式地从Java的标准根类Object进行继承。

1. 继承需要先声明“新类与旧类相似”。
2. 这种声明是通过在类的左边花括号之前，书写后面紧随基类名称的关键字**extends**而实现的。
3. 当这么做时，就会自动获获得基类中所有的域和方法。

```java
public class ExpandedClass extends BasedClass {
	//...
}
```

在此引入几个Java特性。

1. 在同一个Java文件中，非public类也可以定一个main()方法，即可为每个类都创建一个main()方法。这在每个类中都设置一个main()方法的技术可使每个类的单元测试都变得加简便易行。
2. 需要被拓展的基类，有个一般性的**规则**：将所有的数据成员指定为private，将所有的方法都指定为public。因为要从其他包中来继承此基类，只能访问public的成员。
3. 基类初始化：在导出类构造对象时，会在构造器中调用基类构造器来执行初始化。

```java
class Art{
	Art() {System.out.println("Art Constructor");}
}

class Drawing extends Art {
	Drawing() {System.out.println("Drawinng Constructor");}
}

public class Cartoon extends Drawing {
	public Cartoon(){System.out.println("Cartoon Constructor");}
	public static void mian(String[] args){
	Cartoon x = new Cartoon;
	}
}/* 
Art Constructor
Drawinng Constructor
Cartoon Constructor
*/
```

- 由此可发现，导出类所构造的对象，还包含了一个基类的子对象。
- 构建过程时从基类“向外扩散的”，因此基类在导出类构造器可以访问它之前，就已经完成了初始化。
- 不过，如果是带参数的基类构造器，就必须用关键字super显示地编写调用基类构造器的语句，并且配以适当的参数列表。

```java
class Art{
	Art(int i) {System.out.println("Art Constructor");}
}

class Drawing extends Art {
	Drawing(int i) {
	super(i);
	System.out.println("Drawinng Constructor");
	}
}

public class Cartoon extends Drawing {
	public Cartoon(){
	super(11);
	System.out.println("Cartoon Constructor");
	}
	public static void mian(String[] args){
	Cartoon x = new Cartoon;
	}
}/* 
Art Constructor
Drawinng Constructor
Cartoon Constructor
*/
```

## 7.3 代理

第三种关系称为代理，Java并没有提供对它的直接支持。这是继承与组合之间的中庸之道。

1. 我们将一个对象成员置于所要构造的类中，但于此同时，我们在新类中通过继承的方式，获取了该对象成员的所有方法。

## 7.4 结合使用组合和继承

同时使用组合和继承是很常见的事情，通过配备必要的构造器初始化，可以获得更加复杂的类。

### 7.4.1 确保正确清理

Java中没有C++中析构函数的概念。析构函数是一种在对象被销毁时可以被自动调用的函数。在Java中，我们习惯忘掉而不是销毁对象，因为可以让垃圾回收器在必要的时候释放内存。

1. 通常这样做是好事，不过有时类可能要在其生命周期内执行一些必要的清理获得。
2. 正如在第五章讨论的那样，我们并不知道垃圾回收器何时将会被调用，或者是否会被调用。
3. 因此，如果你需要某个类清理一些东西，就必须显式地编写一个特殊方法来做这件事情，并确保客户端程序员知晓它们必须要调用这一方法。
4. 在第十二章会讨论，必须将这一清理动作置于finalize()方法中。

### 7.4.2 名称屏蔽（Override）

如果Java的基类拥有某个已被多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽其在基类中的任何版本。

1. 在导出类中定义了一个方法，与基类的一个方法重名，如果特征签名或返回类型不同，则会进行方法重载。
2. 如果两个方法同名，且特征签名也相同，返回类型也相同，则会导出类的方法会覆盖基类的方法。
3. Java SE5新增了**@Override**注解，这个关键字指示下面的方法是覆写，而不是重载。
4. 如果不留心（特征签名和返回类型写错了），编译器会生成错误信息。
5. 这样@Override注解可以防止我们在不想重载时而意外地进行了重载。

## 7.5 在组合与继承之间选择

组合和继承都运行在新的类中放置子对象，组合是显示地这样做，而继承是隐式地做。

**问题**：二者间的区别何在，以及怎样在二者之间做出选择？

1. 组合技术通常用于想使用现有类的功能，而非它的接口这种情形。
2. 允许类的用户直接访问新类中的组合成分是极具意义的。
3. 比如car对象，car由多个部件组成，而每个构件各有独特的驱动动作。
4. 在car中构造各个部件的对象，再构建一个car的对象，在car的对象中调用部件对象的方法。
5. 在car这个类中，表现了组合也同样是非常重要的一种代码复用方式。

## 7.6 protected关键字

在理想状态下，关键字private就已经足够了，但在实际项目中，经常会想将某些事物尽可能对这个世界隐藏起来，但仍允许导出类的成员访问它们。

1. protected指明：就类用户而言，这是protected的，但对于任何继承此类的导出类或其他任何位于同一个包内的类来说，它是可访问的。
2. protected也提供了包内访问权限。
3. 虽然可以创建protected字段，不过尽量还是使用private。

## 7.7 向上转型

“为新的类提供方法”并不是继承技术中最重要的方面，最重要的方面是用来表现新类和基类之间的关系。这种关系可以用“新类是现有类的一种类型”这句话来概括。

```java
class Instrument {
	public void play();
	static void tune(Instrument i) {
		i.play();
	}
}

public class Wind extends Instrument {
	public static void main(String[] args) {
		Wind flute = new Wind();
		Instrument.tune(flute);
	}
}
```

1. 在上述代码中，tune()方法可以接受Instrument引用。
2. Java有着严格的类型检查，接受某种类型的方法同样可接受另外一种类型会显得很奇怪。
3. 不过我们意识到Wind对象也同样是Instrument对象。
4. 在tune()中，程序可以对Instrument和它所有的导出类起作用，这种将Wind引用转换为Instrument引用的动作，我们称为向上转型。

## 7.8 final关键字

根据上下文环境，Java的关键字final的含义存在着细微的区别，但通常它指的是“这是无法改变的”。不想改变的理由可能如下：设计和效率。

1. 一个永不改变的编译时常量。
2. 一个在运行时被初始化，而我们不希望它改变。
3. 必须在字段的定义处或者每个构造器中用表达式对final进行赋值。

使用final方法对原因也有两个：第一个是把方法锁定，以防任何继承类修改它的含义。第二个原因是效率：如果将一个方法指明为final，就同意编译器针对该方法的所有调用都转为内嵌调用。

使用final类，则表明不打算继承该类，而且也不允许其他人这样做。这也意味着对该类的设计永不需任何改动。

## 7.9 初始化及类的加载

1. Java每个类的编译代码都存在于它自己的独立文件中。该方法只需使用程序代码时才会被加载。
2. 换句话说：类的代码在初次使用时才会被加载。

初始化的顺序如下：

1. 找出与运行的Java文件名相同的类的main()方法。（称其为主类）
2. 加载器开始启动并找出主类的编译代码（主类的.class文件中）
3. 加载时，如果发现有一个基类，会加载这个基类(.class)
4. 如果这个基类还有自身的基类，那么第二个基类会被加载，以此类推。
5. 最后，根基类的static初始化，即执行static的相关代码。
6. 下一个则是根基类的导出类的static初始化。
7. 导出类的static初始化取决于基类成员能否被正确初始化。
8. 至此，必要的类都已经加载完了，对象可以创建了。
9. 首先，对象中所有的基本类型都会被设置为默认值，对象引用为null。
10. 然后，基类的构造器会被调用，可以被自动调用，也可以用super指定基类的构造器。
11. 基类的构造器和导出类的构造器一样，以相同的顺序来经历相同的过程。
12. 在基类构造器完成后，实例变量按其次序被初始化。
13. 最后，构造器的其余部分被执行。

# chapter 08 多态

在面向对象的程序设计语言中，多态是继数据抽象（封装）和继承之后的第三种基本特征。

1. **多态**通过分离做什么和怎么做，从另一角度将接口和实现分离开来。
2. **封装**通过合并特征和行为来创建新的数据类型。
3. **实现隐藏**则通过细节“私有化”把接口和实现分离开来。

多态的作用是消除类型之间的耦合关系。继承允许将对象视为它自己本身的类型或其基类型来处理。

1. 即允许多种类型（同一基类导出）视为同一类型来处理。
2. 这样同一份代码可以毫无差别的允许在这些不同的类型之上了。
3. 多态方法调用允许一种类型表现出与其他相似类型之间的区别。

## 8.1 再论向上转型

对象既可以作为它自己本身的类型使用，也可以作为它的基类型使用。而这种把某个对象的引用是为对其基类的引用的做法，被称为**向上转型**—因为在继承树的画法中，基类是放置在上面的。

```java
package music;

public enum Note {
    MIDDLE_C, C_SHARP, B_FLAT;
}
```

```java
package music;

public class Instrument {
    public void play(Note n) {
        System.out.println("music.Instrument.play()");
    }
}
```

```java
package music;

public class Wind extends Instrument {
    @Override
    public void play(Note n) {
        System.out.println("Wind.play() " + n);
    }
}
```

```java
package music;

public class Music {
    public static void tune(Instrument i) {
        i.play(Note.MIDDLE_C);
    }

    public static void main(String[] args) {
        Wind flute = new Wind();
        tune(flute);
    }
} /* Output
Wind.play() MIDDLE_C
```

**问题**：为什么使用基类的引用，却能调用对象原本类型的方法？

### 8.1.1 忘记对象类型

**问题**：定义一个方法，不选择对象的类型，而且选择其基类型作为传入参数，为什么像是故意遗忘对象的类型呢？

1. 如果选择对象的类型，则需要为基类的每一个导出类编写对应的方法。

## 8.2 转机

**问题**：如果一个方法的传入参数是这个对象的基类，编译器怎样才能知道这个基类的引用（形参）指向的是对象的类型（实参）？

实际上，编译器无法得知。为了深入理解这个问题，有必要研究一下绑定这个话题。

### 8.2.1 方法调用绑定

将一个方法调用同一个方法主体关联起来被称作绑定。

1. 若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现），叫做前期绑定。
2. 上面提到的问题令人疑惑，是因为前期绑定时，只有一个基类的引用。
3. 解决的办法是后期绑定，它的含义就是在运行时根据对象的类型进行绑定。
4. 后期绑定也叫做动态绑定或运行时绑定。
5. 一种语言想实现后期绑定，就必须具备某种机制，在对象中安置某种“类型信息”。
6. **Java中除了static和final方法（pivate方法属于final方法）之外。其他所有的方法都是后期绑定。**

### 8.2.2 产生正确的行为

一旦知道Java中所有方法是通过动态绑定实现多态这个事实之后，我们就可以编写只与基类打交道的程序代码了，并且这些代码对所有导出类都可以正确运行。

1. 发送消息给某个对象，让对象去判定应该做什么事。

2. 比如在经典的“几何形状”(shape)例子中，Shape类中有draw()和erase()两种方法，它的导出类Circle、Square和Triangle也都各自实现了该方法。

   ```java
   Shape s = new Circle();
   ```

3. 这里，创建了一个Circle对象，并把得到的引用立刻赋值给Shape。

4. 这样做看似错误（将一种类型赋值给另一种类型），但实际上没问题，因为通过继承，Circle就是一种Shape。

5. 假设我们调用一个基类方法（它在导出类中已被覆盖）

   ```java
   s.draw();
   ```

6. 我们原本可能认为调用的Shape的draw()，因为s毕竟是一个Shape引用，那么编译器是怎样知道这个方法是做其他事情的呢？

7. 由于后期绑定（多态），还是正确调用了Circle.draw()方法。

### 8.2.3 可拓展性

在“乐器(Instrument)”示例中，由于有多态机制，我们根据自己的需求对系统添加任意多的新类型，而不需要更改tune()方法。在一个设计良好的OOP程序中，所有方法都会遵循tune的模型，而且只与基类接口通信。这样的程序是**可拓展的**，因为可以从通用的基类继承出新的数据类型，从而添加一些功能。

### 8.2.4 缺陷：“覆盖”私有方法

如果我们在基类中定义了一个私有方法，并在导出类中试图覆盖它。这样做是不可取的，因为private被自动认为是final方法，对导出类是屏蔽的，因此，在这种情况下，导出类重写的方法是一个全新的方法。这样由导出类构造的对象，若使用基类的引用是无法加载出导出类的方法。

1. 结论就是，只有非private方法才可以被覆盖。

### 8.2.5 缺陷：域与静态方法

一旦了解多态的机制，我们可能会认为所有事物都可以多态的发生。然而，只有普通的方法调用时多态的。如果直接访问某个域，这个访问就将在编译期进行解析。

1. 同理，用基类引用其导出类的对象，我们可以对普通方法进行动态绑定，但是直接访问域的时候，只能访问基类中的域，而不能动态的去访问导出类中的域。
2. 另外，最好不要对基类中的域和导出类中的域赋予相同的名字，因此这样做会混淆。

如果某个方法是静态的，它的行为就不具有多态性。

## 8.3 构造器和多态

构造器不同于其他种类的方法。涉及到多态时仍是如此。尽管构造器并不具备多态性（隐式static申明），但还是非常有必要理解构造器怎样通过多态在复杂的层次结构中运作。有助于避免一些令人不快的困扰。

### 8.3.1 构造器的调用顺序

简单的描述：基类的构造器总是在导出类的构造过程中被调用，而且按照继承层次逐渐向上链接，以使得每个基类的构造器都能得到调用。

1. 这样做的意义在于：检查对象被正确的构造。
2. 导出类只能访问自己的成员，不能访问基类的成员（基类成员通常时private类型）。
3. 只有基类的构造器材具有恰当的知识和权限来对自己的元素进行初始化。
4. 因此，必须令所有构造器都得到调用，否则就不可能构造完整对象。

```java
package constructor;

class Meal{
    Meal() {
        System.out.println("Meal()");
    }
}

class Bread {
    Bread() {
        System.out.println("Bread()");
    }
}

class Cheese {
    Cheese() {
        System.out.println("Cheese()");
    }
}

class Lettuce {
    Lettuce() {
        System.out.println("Lettuce()");
    }
}

class Lunch extends Meal{
    Lunch() {
        System.out.println("Lunch()");
    }
}

class PortableLunch extends Lunch {
    PortableLunch() {
        System.out.println("PortableLunch()");
    }
}

public class Sandwich extends PortableLunch{
    private Bread b = new Bread();
    private Cheese c = new Cheese();
    private Lettuce l = new Lettuce();
    public Sandwich(){
        System.out.println("Sandwich()");
    }
    public static void main(String[] args) {
        new Sandwich();
    }
}/* Output
Meal()
Lunch()
PortableLunch()
Bread()
Cheese()
Lettuce()
Sandwich()
*/
```

1. 调用基类构造器，递归直至根类的构造器。然后是下一层导出类，一直到最底层的导出类。
2. 按声明顺序调用成员的初始化方法。
3. 调用导出类构造器的主体。

构造器的调用顺序是非常重要的！！！

当进行继承的时候，我们已经知晓了基类的一切，并且可以访问基类中任何声明为public和protected的成员。这意味着在导出类中，必须假定基类的所有成员都是有效的。

### 8.3.2 继承与清理

通过组合和继承方法来创建新类时，永远不必担心对象的清理问题，子对象通常都会留给垃圾回收器进行处理。如果确实遇到清路的问题，那么就必须用心为新类创建dispose()方法。

1. 由于继承的缘故，如果我们其他作为垃圾回收的一部分的特殊清理动作。
2. 就必须在导出类中覆盖dispose()方法。
3. 当覆盖被继承类的dispose()方法时，务必记住调用基类版本的dispose()方法，否则基类的清理动作不会发生。

### 8.3.3 构造器内部的多态方法的行为

构造器调用的层次结构带来了一个有趣的两难问题。

**问题**：如果在一个构造器的内部，调用正在构造的对象的某个动态绑定方法，那么会发生什么？

1. 如果要调用构造器内部的一个动态绑定方法，就要用到那个方法的被覆盖后的定义。
2. 然后被覆盖的方法在对象被完全构造之前就会被调用。这可能发生一些难以发现的隐藏错误。
3. 在任何构造器内部，整个对象可能只是部分形成—我们只知道基类对象已经进行初始化。
4. 如果构造器只是在构建对象过程中的一个步骤，并且该对象所属的类是从这个构造器所属的类导出的，那么导出部分在当前构造器正在被调用的时刻，仍旧是没有被初始化的。
5. 然而，一个动态绑定的方法调用却会向外深入到继承层次结构内部，它可以调用导出类的方法。
6. 若是此时，这个方法要调用未初始化的成员，那么就会出现问题。

## 8.4 协变返回类型

Java SE5中添加了协变返回类型，它表示在导出类中的被覆盖方法可以返回基类方法的返回类型的某种导出类型。

## 8.5 用继承进行设计

学习了多态之后，看起来所有东西都可以被继承，因为多态是一种如此巧妙的工具。事实上，当我们使用现成的类来建立新类时，如果首先考虑使用继承技术，反倒会加重我们的设计负担，使事情变得不必要地复杂。

更好的方式时首先选择“组合”，尤其是不能十分确定应该使用哪一种方式时。

**通用准则**：用继承表达行为上的差异，用字段表达状态上的变化。

1. 通过继承可以得到不同的类，用于表达方法的变化。
2. 通过组合不同的类，以操作不同行为的对象。

### 8.3.1 纯继承与拓展

“**is-a**”（纯替代的关系）：导出类完全替代基类，即导出类具备基类的所有接口。

1. 基类可以接受且发送给导出类的任何消息。
2. 因为二者拥有完全相同的接口。
3. 只需要从导出类向上转型，永远不需要知道正在处理的对象的确切类型。
4. 通过多态的运行时绑定机制，方法的调用会自动绑定对象的实际类型。

“**is-like-a**”（像一个的关系）：因为导出类除了有着基类的全部接口，还拥有额外方法来实现其他的特性。

1. 有一个非常明显的缺点，导出类中接口的拓展部分不能被基类访问。
2. 因此不能对某些拓展的方法进行向上转型。

### 8.3.2 向下转型与运行时类型识别

由于向上转型（在继承层次向上移动）会丢失具体的类型信息，所以，我们想通过向下转型（在继承层次向下移动）— 应该能够获取类型信息。

**问题**：我们都知道，向上转型是安全的，因为基类的接口不会大于导出类的接口。但对于向下转型，导出类的接口可能会大于基类的接口，包含基类所没有的方法，因此我们需要某种方法来确保向下转型的正确性。

1. C++中需要一个特殊的操作来获得安全的向下转型
2. 在Java中，所有转型都会得到检查—“**运行时类型识别**”（RTTI）

# Chapter 09 接口

**接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法**

这种机制在编程语言中并不通用。例如，C++对这些概念只有间接的支持。在Java中存在语言关键字这个事实表明人们认为这些思想是很重要的，以至于要提供对它们的直接支持。

首先，我们将学习抽象类，它是普通的类与接口之间的一种中庸之道。尽管在构建具有某些未实现的类时，你的第一想法可能是创建接口，但是抽象类仍旧是用于此目的的一种重要而必须的工具。**因为你不可能总是使用纯接口。**

## 9.1 抽象类和抽象方法

我们创建抽象类是希望通过一个通用接口操纵一系列类，不同的子类可以用不同的方式表示此接口。

1. 为此，Java提供一个叫做抽象方法的机制，这个方法是不完整的，仅有声明而没有方法体。

   ```java
   abstract void f()
   ```

2. 包含抽象方法的类叫**抽象类**。如果一个类包含一个或多个抽象方法，该类必须被限定为**抽象的**。

3. 如果从一个抽象类继承，并想创建该新类的对象，那么就**必须**为基类中的**所有抽象方法**提供方法定义。如果没这么做，那么编译器将会强制要求我们用abstract关键字来限定这个新类。

4. 创建抽象类和抽象方法非常有用，因为它们可以使类的抽象性明确起来，并告诉用户和编译器打算怎样来使用它们。

5. 抽象类还是很有用的重构工具。因为它们使得我们可以很容易地将公共方法沿着继承层次结构向上移动。

## 9.2 接口

**interface**关键字使抽象的概念更向前迈进了一步。

1. abstarct关键字允许人们在类中创建一个或多个没有任何定义的方法—提供接口的部分，但不具体实现。
2. interface这个关键字产生了一个完全抽象的类，它根本就没有提供任何具体实现。
3. 它允许创建者确定方法名、参数列表和返回类型。但是没有任何方法体。

一个接口表示：所有实现了该特定接口的类，看起来都像这样。

1. 因此，任何使用某特定接口的代码都知道可以调用该接口的哪些方法，而且仅需知道这些。
2. 接口被用来建立类与类之间的协议。

想要创建一个接口，需要用interface关键字来替代class关键字。

1. 就像类一样，可以在前面添加public关键字，但是仅限于该接口在同名的文件中被定义。
2. 如果不添加public，那么它只有包访问权限，这样只能在一个包内使用。
3. 接口也可以包含域，但这些域是隐式地static和final。

要让一个类遵循某个特定接口（或者是一组接口），需要使用**implements**关键字。

1. 可以选择在接口中显示地将方法声明为public，但即使你不这么做，它们也是public的。

## 9.3 完全解耦

只要一个方法操作的是类而非接口，那么我们就只能使用这个类及其子类。如果想要将这个方法应用于不在此继承结构中的某个类，那么就会很糟糕。接口可以在很大程度上放宽这种限制，因此，它使得我们可以编写可复用性更好的代码。

## 9.4 Java中的多重继承

接口不仅仅只是一种更纯粹形式的抽象类，它的目标更高。

1. 因为接口没有任何具体的实现—也就是说，没有任何与接口相关的存储。
2. 因此，也无法阻止多个接口的组合。
3. 在C++中，组合多个类的接口的行为被称作**多重继承**。每个类都有一个具体的实现。
4. 在Java中，我们可以执行相同的行为，但是只有一个类可以有具体实现。因此可以组合多个接口。

在导出类中，不要求它继承于一个抽象的或具体的基类，如果必须要从一个非接口的类继承，那么只能从一个类区继承。其余元素都必须是接口。

1. 需要将所有的接口名都置于implements关键字之后，用逗号将其一一隔开。
2. 可以继承任意多个接口，并可以向上转型为每个接口，因为每个接口都是一个独立类型。

**核心原因**：为了能够向上转型为多个基类型（接口）

其他原因：同抽象类一样，防止客户端程序员创建该类的对象。

## 9.5 通过继承来拓展接口

通过继承，可以很容易地在接口中添加新的方法申明，还可以通过继承在新接口中组合数个接口。

### 9.5.1 组合接口时的名字冲突

**问题**：在实现多重继承时，可能会碰到一个小陷阱。如果一个导出类，在其基类和接口中，有一个同名的方法。如果它们的签名和返回类型相同，则会覆写。但如果不同，会发生什么？

覆写、重载会混在一起。

请不要在组合的不同接口中定义同名的方法，如果不这样做可能会招致混乱。

## 9.6 适配接口

接口最吸引人的原因之一就是允许同一个接口具有多个不同的具体实现。在简单的情况中，它的体现形式通常是一个接受接口类型的方法。而该接口的实现和向该方法传递的对象，则取决于方法的使用者。

接口的一种常见用法：**策略设计模式**

1. 编写一个执行某些操作的方法，而该方法将接受一个同样是你指定的接口。
2. 我们主要声明：我们可以用任何我们想要的对象来调用我的方法，只要你的对象遵循我的接口。

Java SE5的Scanner类的构造器接受的就是一个Readable接口。

1. Readable单独为Scanner创建的，以使得Scanner不必将其参数限制为某个特定类。
2. 通过这种方式，Scanner可以作用于更多的类型。
3. 如果我们创建了一个新的类，并且想让Scanner可以作用于它，那么你就应该让它实现Readable。

## 9.7 接口中的域

因为我们放入接口中的任何域都自动是static和final的，所以接口就成为了一种很便捷的用来创建常量组的工具。不过现在有枚举类enum。

## 9.8 嵌套接口

接口可以嵌套在类和其他接口中。

1. 在类中嵌套接口的语法同非嵌套接口一样，可以拥有public和“包访问”两种可视性。
2. 不过在嵌套中的接口，还可以被实现为private（同样，嵌套类也具备这样的特性）。
3. 当在一个A类中，创建一个private接口，并为该接口实现一个public的D类，我们为该类创建一个对象，即返回一个引用，这个引用只能由A类所构造的另外一个对象来使用。

**困惑**：这个特性看起来非常变扭，不过Bruce Eckel认为一旦了解某种特性，就总能够找到它的用武之地。

## 9.9 接口与工厂

接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式就是**工厂方法设计**模式。

1. 这与直接调用构造器不同，我们在工厂对象上调用的是创建方法，而该工厂对象将生成接口的某个实现的对象。
2. 通过这种方式，我们的代码将完全**与接口的实现分离**。

**问题**：为什么要添加这种额外的间接性呢？

一个常见的原因是想要创建框架。

# Chapter 10 内部类

**可以将一个类的定义放在另一个类的定义内部，这就内部类。**

## 10.1 创建内部类

创建内部类的方式就如同你想的一样—把类的定义置于外围类的里面。

1. 如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须具体指明这个对象的类型：

   OuterClassName.InnerClassName。

## 10.2 链接到外部类

内部类除了名字隐藏和组织代码的模式，还有其他的用途。

1. 当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系。
2. 它能访问外围对象的所有成员，而不需要任何特殊条件。
3. 此外，内部类还拥有外围类的所有元素的访问权。

## 10.3 使用.this和.new

如果你需要生成对外部对象的引用，可以使用外部类的名字后面紧跟原点和this。这样产生的引用自动地具有正确的类型。

1. OuterClassName.this

有时我们可能想要告知某些其他对象，去创建其某个内部类的对象。这是需要使用.new语法。

```java
public class DotNew{
	public class Inner{}
	public static void main(String[] args){
		DotNew dn = new DotNew();
		DotNew.Inner dni = dn.new Inner();
	}
}
```

想要直接创建内部类的对象，我们不能按照我们想象的方式，去引用外部类的名字DotNew。

1. 必须使用外部类的对象来创建该内部类对象。
2. 在拥有外部类对象之前时不可能创建内部类对象的。因为内部类对象会暗暗地连接到创建它的外部类对象上。
3. 如果创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。

## 10.4 内部类与向上转型

当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。

1. 实现了某个接口的对象。
2. 得到对此接口的引用。
3. 向上转型为这个对象的基类。

此时内部类由于完全不可见，并且不可用。所得到的只是指向基类或接口的引用，因而能够很方便的隐藏实现细节。

## 10.5 在方法和作用域内的内部类

上述的仅是内部类的典型用途。这些“平凡的”内部类，简单并且容易理解。然而，内部类的语法涵盖了大量其他的更加难以理解的技术。理由如下：

1. 如前所示，实现了某类型的接口，于是可以创建并返回对其对引用。
2. 我们要解决一个复杂的问题，想创建一个类来辅助我们的解决方案，但又不希望这个类是公共可用的。

## 10.6 匿名内部类

通过下面的例子来引入匿名的概念

```java
public class parcel7{
	public Contents contents {
		return new Contents() {
			private int i = 11;
			public int value() {return i;}
		};
	}
	
	public static void main(String[] args) {
		Parce17 p = new Parcel7();
		Contents c = p.contents();
	}
}
```

1. contents()方法将返回值的生成与表示这个返回值的类的定义结合在一起！
2. 另外，这个类是匿名的，没有名字
3. 这个奇怪的语法指的是：创建一个继承自Contents的匿名类的对象。
4. 通过new表达式返回的引用，被自动向上转型为对Contents的引用。
5. 匿名内部类末尾的分号，不是表示内部类的结束，而是表示return这个表达式的结束。

**注意**：优先使用类而不是接口。如果你的设计中需要某个接口，请你必须了解它。否则，不到迫不得已，不要将其放到你的设计之中。

## 10.7 嵌套类

如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static。

### 10.7.1 接口内部的类

### 10.7.2 从多层嵌套类中访问外部类的成员

## 10.8 为什么需要内部类

**问题**：为什么需要内部类？

1. 如果只是需要一个对接口的引用，为什么不通过外围类实现那个接口呢？

   答：如果这能满足需求，那么就应该这样做。

2. 内部类实现一个接口与外围类实现这个接口有什么区别吗？

   答：后者不是总能享用到接口带来的方便，有时需要用到接口的实现。

3. 所以，使用内部类最吸引人的原因是：

   **每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。**

**考虑如下一种情况**：

1. 即必须在一个类中以某种方式实现两个接口。
2. 由于接口的灵活性，我们可以使用单一的类来实现，也可以用内部类
3. 当然，无论哪种实现都是有意义的，不过遇到问题时，通常问题本身会给出指引。
4. 比如需要实现或拓展是抽象的类或具体的类，而不是接口，那就只能使用内部类才能实现多重继承。

## 10.9 总结

1. 比起面向对象编程中的其他概念来，接口和内部类更深奥复杂。
2. 将两者结合起来，能够解决C++中用多重继承所能解决的问题。
3. 然而，多重继承在C++中被证明是相当难用的。
4. 相较而言，Java的接口和内部类就容易理解多了。

**注意**：虽然这些特性本身是相当直观的，但是就像多态机制，这些特性的使用应该是在设计阶段考虑的问题。

# chapter 11 持有对象

**如果一个程序只包含固定数量的且生命周期都是已知的对象，那么这是一个非常简单的程序**

**问题**：程序总是根据运行时才知道的某些条件去创建新对象，在此之前，不会知道所需对象的数量，甚至不知道确切的类型。为了解决这个普遍的编程问题，需要在任意时刻和任意位置，创建任意数量的对象。

**方案**：Java实用类库提供了一套相当完整的容器类来解决这个问题，其中基本的类型就是List、Set、Queue和Map。

## 11.1 泛型和类型安全的容器

1. 最基本最可靠的容器ArrayList

2. 用add()插入对象，用get()访问对象，用size()获取元素的数量

3. 如果一个类没有显式地申明继承自哪个类，它将自动地继承自Object()

4. 可以使用预定义的泛型来申明容器中保存的类型，尖括号内的就是**类型参数**（可以有多个）。

   ```java
   ArrayList<>
   ```

5. 通过使用泛型，就可以在**编译期**防止将错误类型的对象放置到容器中。

6. 当我们指定了某个类型作为泛型参数时，我们并不仅限于只能将该确切类型的对象放置到容器中。向上转型也可以像作用于其他类型一样，作用于泛型。

## 11.2 基本概念

Java容器类库的用途时是“保存对象”，并将其划分为两个不同的概念。

1. **Collection**：一个独立元素的序列，这些元素服从一条或多条规则。其中包含List、Set、Queue。
2. **Map**：一组成对的“键值对”对象，允许使用键来查找值。其中包含ArrayList

在编写大部分的代码时，我们都是在与一些接口打交道，并且我们唯一需要指定所使用的精确类型的地方就是在创建的时候。

```java
List<Apple> apples = new ArrayList<Apple>();
```

1. **注意**，此时ArrayList已经被向上转型为List。

2. 使用接口的目的在于如果我们决定去修改这个实现，我们所需的只是在创建处修改它。

   ```java
   List<Apple> apples = new LinkedList<Apple>();
   ```

3. 因此，我们应该创建一个具体类的对象，将其转型为对应的接口，然后在其余的代码中都使用这个接口。

4. 不过这个方式并非总是奏效的，因为某些类具有额外的功能，如果使用了这些方法，我们就不能将它们向上转型为更通用的接口。

## 11.3 添加一组元素

在java.util包中的Arrays和Collections类中有很多实用方法，可以在一个Collection中添加一组元素。

1. Arrays.asList()方法接受一个数组或是一个用逗号分隔的元素列表，并将其转换为一个List对象。

   ```java
   List<Integer> list = Array.asList(1, 2, 3, 4, 5);
   ```

2. Collections.addAll()方法可以构建一个不包含元素的Collection，然后为其中增添元素。

   ```java
   Collection<Integer> collection = new ArrayList<Integer>(Arrays.asList(1, 2, 3, 4, 5));
   Collections.addAll(collection, 6, 7, 8, 9, 10);
   Collections.addAll(collection, 6, 7, 8, 9, 10);
   ```

3. 如果直接使用Arrays.asList()的输出，将其当作List，但是在这种情况下，其底层表示的是数组，因此不能调整尺寸。如果尝试用add()或delete()方法在这种列表添加或删除元素，会因操作数组尺寸而出现错误。

4. Arrays.asList方法的限制是它对所产生的List的类型做出了最理想的假设，而没有注意你会对它赋予什么样的类型。

## 11.4 容器的打印

我们必须使用Arrays.toString()来产生数组的可打印表示，但是打印容器无需任何帮助。

1. 容器提供了toString()方法，可生成可读性很好的结果。
2. ArrayList、LinkedList都是List类型。
3. HashSet、TreeSet和LinkedHashSet都是Set类型。
4. HashMap、TreeMap和LinkedHashMap都是Map类型。

## 11.5 List

List承诺可以将元素维护在特定的序列中。List接口在Collection的基础上添加了大量的方法，使得可以在List的中间插入和移除元素。有两种类型的List：

1. ArrayList，擅长随机访问元素，但是在插入和移除元素时较慢。
2. LinkedList，擅长插入和删除元素，但是在访问方面较慢。
3. 可以用contains()方法来确定某个对象是否还在列表中。
4. 如果想移除一个对象，则可以将这个对象的引用传递给remove()方法。
5. 如果有一个对象的引用，则可以使用indexof()来发现该对象在List所处位置的索引编号。
6. 上面的确认对象、发现索引和移除对象都依赖于equals()方法。
7. subList()方法允许你很容易地从较大的列表中创建一个片段。

## 11.6 迭代器

任何容器类，都必须有某种方式可以插入元素并将它们取回。毕竟，持有事物是容器最基本的工作。对于List，add()是插入元素的方法之一，而get()是取出元素的方法之一。

**问题**：要使用容器，就必须对容器的确切类型编程，如果在后面发现，能够把相同的代码应用于set，那么就会非常的方便，此时怎么做呢？如何才能不重写代码就可以应用于不同类型的容器？

**迭代器**（也是一种设计模式）的概念可以用于达成此目的。

1. 迭代器是一个对象，它的工作是遍历并选择序列中的对象。
2. 迭代器通常称为**轻量级对象**：创建它的代价小。
3. 因此，经常可以见到对迭代器有些奇怪的限制，Java中的Iterator只能单向移动。

- 使用方法iterator()要求容器返回一个Iterator。Iterator将准备好返回序列的第一个元素。
- 使用next()获得序列的下一个元素。
- 使用hasNext()检查序列中是否还有元素。
- 使用remove将迭代器新近返回的元素删除。

Iterator能够将遍历序列的操作与序列底层的结构分离。（我们有时会说：迭代器统一了对容器的访问方式）

### 11.6.1 ListIterator

ListIterator是一个更加强大的Iterator的子类型，它只能用于各种List 的访问，且它能够双向移动。

## 11.7 LinkedList

LinkedList添加了可以使其作为栈、队列或双端队列的方法。

## 11.8 Stack

“栈”通常指“后进先出”（LIFO）的容器。因为最后“压入”栈的元素，第一个“弹出”栈。

## 11.9 Set

Set不保存重复的元素。如果试图将相同对象的多个实例添加到Set中，那么它就会阻止这种重复现象。

1. Set中最常被使用的是测试归属性。
2. 我们可以很容易地询问某个对象是否在某个Set中。
3. 正因为如此，查找就成为了Set中最重要的操作。
4. 通常我们会选择一个HashSet的实现，它专门对快速查找进行了优化。
5. Set具有与Collection完全一样的接口，因此没有任何额外的功能，不像前面有两个不同的List。

## 11.10 Map

将对象映射到其他对象的能力是一种解决编程问题的杀手锏。

## 11.11 Queue

队列是一个典型的先进先出（FIFO）的容器。即从容器的一端放入事物，从另一端取出，并且事物放入容器的顺序与取出的顺序是相同的。

1. 队列常被当作一种可靠的将对象从程序的某个区域传输到另一个区域的途径。
2. 队列在并发编程中特别重要，因为它们可以安全地将对象从一个任务传输给另一个任务。
3. LinkedList提供了方法以支持队列的行为，并且它实现了Queue接口。
4. 可以将LinkedList向上转型为Queue。

## 11.12 Collection和Iterator

Collection是描述所有序列容器的共性的根接口，它可能被认为是一个“附属接口”，即因为要表示其他若干个接口的共性而出现的接口。

1. 使用接口描述的一个理由是它可以使我们创建更通用的代码。
2. 通过针对接口而非具体实现来编写代码，我们的代码可以用于更多的对象类型。
3. 标准C++类库中没有容器的任何公共基类—容器之间的共性通过迭代器来实现的。
4. 在Java中，两种方法绑定到了一起，实现Collection意味着需要提供iterator()方法。

## 11.13 Foreach与迭代器

到目前为止，foreach语法主要用于数组，但是它也可以用于任何Collection对象

```java
public class ForEachCollections {
	public static void main(String[] args) {
		Collection<String> cs = new LinkedList<String>();
		Collections.addAll(cs, "Take the long way home".split(" "));
		for (String s : cs) {
			System.out.print(" " + s + " ");
		}
	}
}
```

1. 之所以能够工作，是因为Java SE5引入了新的被称为Iterable的接口。
2. 该接口包含了一个能够生产Iterator的iterator()方法。
3. 并且Iterable接口被foreach用来在序列中移动。
4. 因此如果创造了任何实现Iterable的类，都可以将它用于foreach语句中。

## 11.14 总结

Java提供了大量持有对象的方式：

1. 数组将数字与对象联系起来。
2. Collection保存单一的元素，而Map保存相关联的键值对。
3. 像数组一样，List也建立数字索引与对象的关联。
4. 如果要进行大量的随机访问，就使用ArrayList；如果经常插入与删除，就使用LinkedList。
5. 各种Queue以及栈的行为，由LinkedList提供支持。
6. Map是一种将对象与对象相关联的设计。HashMap设计用于快速访问；而TreeMap保持“键”始终处于排序状态，所以没有HashMap块；LinkedHashSet保持元素插入的顺序，但也通过散列提供了快速访问的能力。
7. 新程序中不应该使用过时的Vector、Hashtable和Stack。
8. 建议浏览Java容器的简图（《Java编程思想》第四版—P245）

# Chapter 12 通过异常处理错误

**Java的基本理念是“结构不佳的代码不能允许”**

发现错误的理想时机是在编译阶段，也就是在你i试图允许程序之前。然而，编译期间并不能找出所有的错误，余下的问题必须在运行期间解决。这就需要错误源能够通过某种方式，把适当的信息传递给某个接收者—该接收者将知道如何处理这个问题。

## 12.1 概念

C以及其他早期语言常常具有多种错误处理模式，这些模式往往建立在约定俗成的基础之上，而并不属于语言的一部分。通常会返回某个特殊值或设置某个标志。

**问题**：如果在每次调用方法的时候都要彻底地进行错误检查，代码很可能变得难以阅读。

**方案**：用强制规定的形式来消除错误处理过程中随心所欲的因素。

1. C++的异常处理机制基于Ada，Java中的异常处理建立在C++的基础之上。
2. “异常”表示对此感到意外，不知道如何处理，但确实不该置之不理。
3. 把问题提交到更高级的环境，在那里作出正确的决定。
4. 使用异常处理的最为明显的好处，降低错误处理代码的复杂度。

## 12.2 基本异常

异常情形（exceptional condition）是指阻止当前方法或作用域继续执行的问题。因此有必要区分普通问题和异常情形。

1. 普通问题：在当前环境下能得到足够的信息，总能处理这个错误。
2. 异常情形：在**当前环境**下无法获得必要的信息来解决问题。
3. 我们所能够做的就是从当前环境跳出，并且把问题提交给上一级环境。即抛出异常。

抛出异常后，有几件事会随之发生。

1. 首先，同Java中其他对象的创建一样，使用new在堆上创建异常对象。

2. 然后，当前的执行路径被终止，并且从当前环境中弹出对异常对象的引用。

3. 此时，异常处理机制接管程序，并开始寻找一个恰当的地方继续执行程序。

4. 这个恰当的地方就是**异常处理程序**，它的任务是将程序从错误状态中恢复。

5. 使程序能要么换一种方式运行，要么继续运行下去。

6. 对于对象引用t，传给你时可能还未初始化。所以在访问这个对象前，先对引用进行检查。

   ```java
   if(t == null) {
   	throw new NullpointerException();
   }
   ```

7. 可以创建一个代表错误信息的对象，并且将它从当前环境中“抛出”，这样就把错误信息传播到了“更大”的环境中。也称为**抛出一个异常**。

8. 抛出异常后，当下环境就不用担心引用为空的问题了。它会在别的地方得到处理

我们可以将异常看作一种内建的恢复(undo)系统，因为我们在程序中可以拥有各种不同的恢复点。如果程序的某部分失败了，异常将“恢复”到程序中某个已知的稳定点上。

### 12.2.1 异常参数

与使用Java中的其他对象一样，我们总是用new在堆上创建异常对象，这也伴随着存储空间的分配和构造器的调用。所有标准异常类都有两个构造器：一个是默认构造器，另一个是接受字符串作为参数，以便能把相关信息放入异常对象的构造器。

```java
throw new NullPointerException("t = null");
```

不久将看到，要把这个字符串的内容提取出来可以有多种不同的方法。

1. 抛出异常与方法正常返回值的相似之处：会返回一个东西，然后退出方法或作用域。
2. 不同之处：异常返回的“地点”与普通方法返回的“地点”完全不同。
3. 异常将在一个恰当的异常处理程序中得到解决，它的位置可能里异常被抛出的地方很远，也可能会跨越方法调用栈的许多层次。
4. 此外，能够抛出任意类型的Throwable对象，它是异常类型的根类。
5. 通常，对于不同类型的错误，要抛出相应的异常。
6. 错误信息可以保存在异常对象内部或用异常类的名称来暗示。以便于上一层环境通过这些信息来决定如何处理异常。

## 12.3 捕获异常

要明白异常是如何被捕获的，必须首先理解**监控区域**(guarded region)的概念。它是一段可能产生异常的代码，并且后面跟着处理这些异常的代码。

### 12.3.1 try块

如果在方法内部抛出了异常（或者在方法内部调用的其他方法抛出了异常），这个方法将在抛出异常的过程中结束。要是不希望方法就此结束，可以在方法内设置一个特殊的块来捕获异常。

1. 因为在这个块里“尝试”各种（可能产生异常的）方法调用，所以称为**try**块，跟在关键字try后面的普通块。

   ```java
   try{
   	// Code that might generate exceptions
   }
   ```

### 12.3.2 异常处理程序

当然，抛出的异常必须在某处得到处理。这个“地点”就是**异常处理程序**，而且针对每个要捕获的异常，得准备相应的处理程序。

1. 异常处理程序紧跟在try块之后，以关键字catch表示：

   ```java
   try{
   	// Code that might generate exceptions
   } catch(Type1 id1) {
   	// Handle exceptions of Type1
   } catch(Type2 id2) {
   	// Handle exceptions of Type2
   } catch(Type3 id3) {
   	// Handle exceptions of Type3
   }
   // etc...
   ```

2. 每个catch子句（异常处理程序）看起来就像是接收一个且仅接收一个特殊类型的参数的方法。

3. 异常处理程序必须紧跟在try块之后，当异常被抛出时，异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序。

4. 终止模式与恢复模式

   异常处理有两种基本模型，Java支持终止模型（它是Java和C++所支持的模型）。还有一种是恢复模型。

## 12.4 创建自定义异常

不必拘泥于Java中已有的异常类型。Java提供的异常体系不可能遇见所有希望报告的错误。所以可以自己定义异常类来表示程序中可能会遇到的特定问题。

1. 要自己定义异常类，必须从已有的异常类中继承，最好选择意思相近的异常类型继承。

2. 建立新的异常类型最简单的方法就是让编译器为你产生默认构造器

   ```java
   Class SimpleException extends Exception {}
   
   public class InheritingExceptions {
   	public void f() throws SimpleException {
   		System.out.print("Throw SimpleException from f()");
   		throw new SimpleException();
   	}
   	public static void main(String[] args) {
   		InheritingException sed = new InheritingExceptions();
   		try {
   			sed.f();
   		} catch(SimpleException e) {
   			System.out.print("Caught it!");
   		}
   	}
   }/*
   Throw SimpleException from f()
   Caught it!
   */
   ```

3. 对于异常来说，最重要的就是类名，因为使用基类的默认构造器就已经足够了。

### 12.4.1 异常与记录日志

如果我们需要使用java.util.logging工具将输出记录到日志中，在书P253页中有一些基础的介绍。

## 12.5 异常说明

Java鼓励人们把方法可能会抛出的异常告知使用此方法的客户端程序员。这是种优雅的做法，它使得调用者能明确知道写什么样的代码可以捕获所有潜在的异常。

1. 如果提供了源代码，客户端程序员可以在源代码中查找throw语句来获知相关信息。
2. 若没有源代码，Java也提供了相应的语法，使我们能够以礼貌的方式告知客户端程序员某个方法可能会抛出的异常类型。
3. 这就是**异常说明**，它属于方法声明的一部分，紧跟在形式参数列表之后。

## 12.6 捕获所有异常

可以只写一个异常处理程序来捕获所有类型的异常。通过捕获异常类型的基类Exception，就可以做到这一点。

1. ```java
   catch(Exception e) {
   	System.out.println("Catch an exception");
   }
   ```

2. 这将捕获所有的异常，最好将它放在处理程序列表的末尾。

3. Exception是与编程有关的所有异常类的基类，它不会含有太多具体的信息，不过它可以调用它从其基类Throwable继承的方法：

   ```java
   String getMessage() // 用来获取详细信息
   String getLocalizedMessage() // 用本地语言表示的详细信息
   //...
   void printStackTrace() //打印Throwab和Throwable的调用栈轨迹，显示“回到异常抛出点”的方法调用序列
   void printStackTrace(PrintStream) // 后个版本允许选择要输出的流
   void printStackTrace(java.io.PrintWriter) //
   //...
   Throwable fillInStackTrace() // 用于在Throwable对象的内部记录栈帧的当前状态
   ```

### 12.6.1 栈轨迹

### 12.6.2 重新抛出异常

### 12.6.3 异常链

## 12.7 Java标准异常

Throwable这个Java类被用来表示任何可以作为异常被抛出的类。

1. Throwable对象可分为两种类型（指从Throwable继承而得到的类型）。
2. Error用来表示编译时和系统错误（一般不用关心）。
3. Exception是可以被抛出的类型，在Java类库、用户方法以及运行时故障中都可能抛出Exception型异常。
4. 如果想对异常有全面的了解，最好浏览一下HTML格式的Java文档。
5. 对异常来说，**关键是理解概念以及如何使用**。

### 12.7.1 RuntimeException

1. 我们不必对传递给方法的每个引用进行检查，是否为null，因为它属于Java的标准运行时检测的一部分。
2. 如果对null引用进行调用，Java会自动抛出NullPointerException异常。
3. 属于运行时异常的类型很多，它们会自动被Java虚拟机抛出，所以不必在异常说明中列出。

## 12.8 使用finally进行清理

对于一些代码，可能会希望无论try块中的异常是否抛出，它们都能够得到执行。

1. 这通常适用于内存回收之外的情况。

2. 为了达到这个效果，可以在异常处理程序后面加上finally子句。

   ```java
   try{
   	// Code that might generate exceptions
   } catch(A a1) {
   	// Handle exceptions of A
   } catch(B b1) {
   	// Handle exceptions of B
   } catch(C c3) {
   	// Handle exceptions of C
   }	finally {
   	// Activities that happen every time
   }
   // etc...
   ```

3. 无论异常是否被抛出，finally子句总能被执行。

### 12.8.1 finally用来做什么

对于没有垃圾回收和析构函数自动调用机制的语言来说，finally非常重要。它能使程序员保证：无论try块里发生了什么，内存总能得到释放。

1. 不过Java有垃圾回收机制，内存释放不再是问题。
2. 当要把除内存之外的资源恢复到它们的初始状态时，就要用到finally子句。
3. 这种需要清理的资源包括：已经打开的文件或网络连接，在屏幕上画的图形。

### 12.8.2 在return中使用fianlly

因为finally子句总是会执行，所以在一个方法中，可以从多个点返回，并且可以保证重要的清理工作仍旧会执行。

### 12.8.3 缺憾：异常丢失

异常作为程序出错的标志，决不应该被忽略，但它还是有可能被轻易地忽略。

## 12.9 异常的限制

当覆盖方法的时候，只能抛出在基类方法的异常说明里列出的那些异常。这个限制很有用，因为这意味着，当基类使用的代码应用到其他派生类对象的时候，一样能够工作。

## 12.10 构造器

我们要时刻询问自己“如果异常发生了，所有东西能被正确的清理吗？”

1. 尽管大多情况是非常安全的，但涉及构造器时，问题出现了。
2. 构造器会把对象设置成安全的初始状态，但还会有别的动作，比如打开一个文件，这样的动作只有在对象使用完毕并且用户调用了特殊的清理方法之后才能得以清理。
3. 如果在构造器内部抛出了异常，这些清理行为也就不能正常工作的了。

## 12.11 异常匹配

抛出异常的时候，异常处理系统会按照代码的书写顺序找出“最近的”处理程序。找到匹配的处理程序后，它就认为异常将得到处理，然后就不再继续查找。

1. 查找的时候并不要求抛出的异常，同处理异常程序所声明的异常完全匹配。
2. 派生类的对象也可以匹配其基类的处理程序。

## 12.12 其他可选方式

1. 异常处理系统就像一个活门（trap door），使你能放弃程序的正常执行序列。
2. 异常处理的重要原则：只有在你知道如何处理的情况下才捕获异常。
3. 使你能在一段代码中专注于要完成的事情，至于如何处理错误，则放在另一段代码中完成。
4. 通常，希望一个处理程序能够处理多个出错点。
5. 避免**吞食则有害**的问题。（**被检查的异常**：肆意使用catch最终导致异常的丢失）

## 12.13 异常使用指南

1. 在恰当的级别处理问题（在知道该如何处理的情况下才捕获异常）。
2. 解决问题并且重新调用产生异常的方法。
3. 进行少许修补，然后绕过异常发生的地方继续执行。
4. 用别的数据进行计算，以替代方案预计会返回的值。
5. 把当前运行环境下能做的事情尽量做完，然后把**相同的**异常重抛到更高层。
6. 把当前运行环境下能做的事情尽量做完，然后把**不同的**异常重抛到更高层。
7. 终止程序。
8. 进行简化（如果异常模式使问题变得太复杂，那用起来也很痛苦）
9. 让类库和程序更安全。

## 12.14 总结

异常是Java程序不可分割的一部分，如果不了解如何使用它们，那么我们只能完成有限的工作。

1. 对于许多类库（比如I/O库），如果不处理异常，我们就无法使用它们。
2. 异常的主要目的就是使得我们可以在某处集中精力处理我们要解决的问题，而在另一地方处理我们编写这段代码中产生的错误。

# chapter 13 





















